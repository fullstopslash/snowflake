---
phase: 02-shared-module
type: execute
---

<objective>
Add TaskwarriorClient and SyncLogger classes to vikunja_common.py.

Purpose: Eliminate duplicated subprocess patterns and inconsistent logging across scripts.
Output: Complete shared module ready for scripts to import.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@vikunja_common.py
@vikunja-direct.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TaskwarriorClient class</name>
  <files>vikunja_common.py</files>
  <action>
  Add to vikunja_common.py:

  ```python
  import subprocess

  class TaskwarriorClient:
      """Client for Taskwarrior CLI operations."""

      SYNC_ENV = {**os.environ, "VIKUNJA_SYNC_RUNNING": "1"}

      def __init__(self, timeout: int = 30):
          self.timeout = timeout

      def _run(self, args: list[str], input_text: str | None = None) -> subprocess.CompletedProcess:
          """Run task command with return code checking."""
          return subprocess.run(
              ["task", *args],
              input=input_text,
              capture_output=True,
              text=True,
              env=self.SYNC_ENV,
              timeout=self.timeout,
          )

      def export_all(self) -> list[dict]:
          """Export all tasks."""
          result = self._run(["export"])
          if result.returncode != 0 or not result.stdout.strip():
              return []
          try:
              return json.loads(result.stdout)
          except json.JSONDecodeError:
              return []

      def export_project(self, project: str) -> list[dict]:
          """Export tasks from a specific project."""
          result = self._run([f"project:{project}", "export"])
          if result.returncode != 0 or not result.stdout.strip():
              return []
          try:
              return json.loads(result.stdout)
          except json.JSONDecodeError:
              return []

      def export_task(self, uuid: str) -> dict | None:
          """Export a single task by UUID."""
          result = self._run([uuid, "export"])
          if result.returncode != 0 or not result.stdout.strip():
              return None
          try:
              tasks = json.loads(result.stdout)
              return tasks[0] if tasks else None
          except (json.JSONDecodeError, IndexError):
              return None

      def modify_task(self, uuid: str, **changes) -> bool:
          """Modify a task. Returns True on success."""
          args = [uuid, "modify"]
          for key, value in changes.items():
              if key == "tags_add":
                  args.extend(f"+{tag}" for tag in value)
              elif key == "tags_remove":
                  args.extend(f"-{tag}" for tag in value)
              elif key == "project":
                  args.append(f"project:{value}")
              elif key == "priority":
                  args.append(f"priority:{value}")
              elif key == "description":
                  args.append(f"description:{value}")
              else:
                  args.append(f"{key}:{value}")
          result = self._run(args)
          return result.returncode == 0

      def add_tags(self, uuid: str, tags: list[str]) -> bool:
          """Add tags to a task."""
          if not tags:
              return True
          return self.modify_task(uuid, tags_add=tags)

      def remove_tags(self, uuid: str, tags: list[str]) -> bool:
          """Remove tags from a task."""
          if not tags:
              return True
          return self.modify_task(uuid, tags_remove=tags)

      def delete_task(self, uuid: str) -> bool:
          """Delete a task. Returns True on success."""
          result = self._run([uuid, "delete"], input_text="yes\n")
          return result.returncode == 0

      def complete_task(self, uuid: str) -> bool:
          """Mark a task as done. Returns True on success."""
          result = self._run([uuid, "done"])
          return result.returncode == 0

      def add_task(self, description: str, project: str | None = None, tags: list[str] | None = None) -> str | None:
          """Add a new task. Returns UUID on success."""
          args = ["add", description]
          if project:
              args.append(f"project:{project}")
          if tags:
              args.extend(f"+{tag}" for tag in tags)
          result = self._run(args)
          if result.returncode != 0:
              return None
          # Parse UUID from output (format: "Created task UUID")
          import re
          match = re.search(r"([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})", result.stdout, re.I)
          return match.group(1) if match else None
  ```

  Key features:
  - All methods check return codes
  - SYNC_ENV prevents hook loops
  - Timeout on all operations
  - Consistent error handling
  </action>
  <verify>python3 -c "from vikunja_common import TaskwarriorClient; print('OK')"</verify>
  <done>TaskwarriorClient class with export, modify, add_tags, remove_tags, delete, complete methods</done>
</task>

<task type="auto">
  <name>Task 2: Add SyncLogger class</name>
  <files>vikunja_common.py</files>
  <action>
  Add to vikunja_common.py:

  ```python
  import sys
  from datetime import datetime, timezone

  class SyncLogger:
      """Structured logger for sync operations."""

      def __init__(self, component: str):
          self.component = component

      def _log(self, level: str, msg: str, **context):
          """Write log entry to stderr."""
          timestamp = datetime.now(timezone.utc).isoformat()
          ctx_str = " ".join(f"{k}={v}" for k, v in context.items()) if context else ""
          entry = f"[{timestamp}] {level} [{self.component}] {msg}"
          if ctx_str:
              entry += f" {ctx_str}"
          print(entry, file=sys.stderr)

      def info(self, msg: str, **context):
          """Log info message."""
          self._log("INFO", msg, **context)

      def warning(self, msg: str, **context):
          """Log warning message."""
          self._log("WARN", msg, **context)

      def error(self, msg: str, **context):
          """Log error message."""
          self._log("ERROR", msg, **context)

      def debug(self, msg: str, **context):
          """Log debug message (only if VIKUNJA_DEBUG is set)."""
          if os.environ.get("VIKUNJA_DEBUG"):
              self._log("DEBUG", msg, **context)
  ```

  Simple, consistent logging format across all components.
  </action>
  <verify>python3 -c "from vikunja_common import SyncLogger; SyncLogger('test').info('hello')"</verify>
  <done>SyncLogger class with info, warning, error, debug methods</done>
</task>

<task type="auto">
  <name>Task 3: Add __all__ export and update default.nix</name>
  <files>vikunja_common.py, default.nix</files>
  <action>
  1. Add at top of vikunja_common.py after imports:
  ```python
  __all__ = [
      "Config",
      "ConfigError",
      "VikunjaClient",
      "TaskwarriorClient",
      "SyncLogger",
  ]
  ```

  2. Update default.nix to include vikunja_common.py in the package.
     Find the installPhase and add vikunja_common.py to the copied files.
     The scripts will import it as `from vikunja_common import ...`

  For the import to work, the file needs to be in the same directory as the scripts,
  or added to PYTHONPATH. Check current default.nix structure and add appropriately.
  </action>
  <verify>grep -l "vikunja_common" default.nix</verify>
  <done>Module exports defined, default.nix includes vikunja_common.py</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] TaskwarriorClient class exists with all methods
- [ ] SyncLogger class exists with info, warning, error, debug methods
- [ ] __all__ exports defined
- [ ] default.nix updated to include vikunja_common.py
- [ ] `python3 -m py_compile vikunja_common.py` passes
- [ ] `cd /home/rain/nix && sudo nixos-rebuild test --flake .#malphas` succeeds
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Shared module complete and ready for use
- NixOS rebuild succeeds with updated package
</success_criteria>

<output>
After completion, create `.planning/phases/02-shared-module/02-02-SUMMARY.md`
</output>
