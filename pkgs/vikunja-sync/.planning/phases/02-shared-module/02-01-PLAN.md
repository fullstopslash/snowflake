---
phase: 02-shared-module
type: execute
---

<objective>
Create vikunja_common.py with Config dataclass and VikunjaClient class.

Purpose: Eliminate duplicated API token loading and Vikunja API patterns across 3+ files.
Output: Reusable Config and VikunjaClient that all scripts can import.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@vikunja-direct.py
@label-sync.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vikunja_common.py with Config dataclass</name>
  <files>vikunja_common.py (new file)</files>
  <action>
  Create new file vikunja_common.py with:

  ```python
  """Shared utilities for vikunja-sync suite."""
  from dataclasses import dataclass
  from pathlib import Path
  import os

  class ConfigError(Exception):
      """Configuration error."""
      pass

  @dataclass
  class Config:
      """Configuration for Vikunja sync."""
      vikunja_url: str
      api_token: str
      caldav_user: str
      caldav_password: str | None = None

      @classmethod
      def from_env(cls) -> "Config":
          """Load configuration from environment variables."""
          vikunja_url = os.environ.get("VIKUNJA_URL", "").rstrip("/")
          if not vikunja_url:
              raise ConfigError("VIKUNJA_URL environment variable not set")

          # Load API token from file
          token_file = os.environ.get("VIKUNJA_API_TOKEN_FILE")
          if not token_file:
              raise ConfigError("VIKUNJA_API_TOKEN_FILE environment variable not set")

          try:
              api_token = Path(token_file).read_text(encoding="utf-8").strip()
          except (FileNotFoundError, PermissionError) as e:
              raise ConfigError(f"Cannot read token file {token_file}: {e}") from e

          if not api_token:
              raise ConfigError(f"Token file {token_file} is empty")

          caldav_user = os.environ.get("VIKUNJA_USER", "")

          # CalDAV password is optional (only needed for correlate)
          caldav_pass_file = os.environ.get("VIKUNJA_CALDAV_PASS_FILE")
          caldav_password = None
          if caldav_pass_file:
              try:
                  caldav_password = Path(caldav_pass_file).read_text(encoding="utf-8").strip()
              except (FileNotFoundError, PermissionError):
                  pass  # Optional, ignore errors

          return cls(
              vikunja_url=vikunja_url,
              api_token=api_token,
              caldav_user=caldav_user,
              caldav_password=caldav_password,
          )
  ```

  Key features:
  - No TOCTOU race (try/except instead of exists check)
  - Strips trailing slash from URL
  - CalDAV password is optional
  - Clear error messages
  </action>
  <verify>python3 -c "from vikunja_common import Config, ConfigError; print('OK')"</verify>
  <done>vikunja_common.py exists with Config dataclass and from_env classmethod</done>
</task>

<task type="auto">
  <name>Task 2: Add VikunjaClient class</name>
  <files>vikunja_common.py</files>
  <action>
  Add to vikunja_common.py:

  ```python
  import json
  from urllib.request import Request, urlopen
  from urllib.error import URLError, HTTPError

  class VikunjaClient:
      """HTTP client for Vikunja API."""

      def __init__(self, config: Config, timeout: int = 30):
          self.config = config
          self.timeout = timeout
          self._label_cache: dict[str, int] = {}

      def _request(self, method: str, endpoint: str, data: dict | None = None) -> dict | list | None:
          """Make HTTP request to Vikunja API."""
          url = f"{self.config.vikunja_url}/api/v1{endpoint}"
          headers = {"Authorization": f"Bearer {self.config.api_token}"}

          body = None
          if data is not None:
              body = json.dumps(data).encode()
              headers["Content-Type"] = "application/json"

          req = Request(url, data=body, headers=headers, method=method)
          try:
              with urlopen(req, timeout=self.timeout) as resp:
                  return json.loads(resp.read().decode())
          except HTTPError as e:
              if e.code == 404:
                  return None
              raise
          except (URLError, json.JSONDecodeError):
              return None

      def get(self, endpoint: str) -> dict | list | None:
          """GET request."""
          return self._request("GET", endpoint)

      def put(self, endpoint: str, data: dict) -> dict | None:
          """PUT request."""
          return self._request("PUT", endpoint, data)

      def post(self, endpoint: str, data: dict) -> dict | None:
          """POST request."""
          return self._request("POST", endpoint, data)

      def delete(self, endpoint: str) -> bool:
          """DELETE request. Returns True on success."""
          try:
              self._request("DELETE", endpoint)
              return True
          except HTTPError:
              return False

      def get_labels(self) -> list[dict]:
          """Fetch all labels."""
          result = self.get("/labels")
          return result if isinstance(result, list) else []

      def get_or_create_label(self, title: str) -> int | None:
          """Get existing label ID or create new one. Uses cache."""
          if title in self._label_cache:
              return self._label_cache[title]

          # Populate cache on first call
          if not self._label_cache:
              for label in self.get_labels():
                  self._label_cache[label.get("title", "")] = label.get("id")

          if title in self._label_cache:
              return self._label_cache[title]

          # Create new label
          result = self.put("/labels", {"title": title})
          if result and "id" in result:
              self._label_cache[title] = result["id"]
              return result["id"]
          return None

      def attach_label(self, task_id: int, label_id: int) -> bool:
          """Attach label to task."""
          try:
              self.put(f"/tasks/{task_id}/labels", {"label_id": label_id})
              return True
          except HTTPError as e:
              return e.code == 409  # Already attached is OK

      def detach_label(self, task_id: int, label_id: int) -> bool:
          """Detach label from task."""
          return self.delete(f"/tasks/{task_id}/labels/{label_id}")

      def get_task(self, task_id: int) -> dict | None:
          """Get task by ID."""
          return self.get(f"/tasks/{task_id}")

      def clear_label_cache(self):
          """Clear label cache (call at start of sync operations)."""
          self._label_cache.clear()
  ```
  </action>
  <verify>python3 -c "from vikunja_common import Config, VikunjaClient; print('OK')"</verify>
  <done>VikunjaClient class with get, put, post, delete, label management methods</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] vikunja_common.py exists in /home/rain/nix/pkgs/vikunja-sync/
- [ ] Config dataclass with from_env classmethod works
- [ ] VikunjaClient class with all methods works
- [ ] No syntax errors: `python3 -m py_compile vikunja_common.py`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Module imports without errors
- Ready for TaskwarriorClient in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/02-shared-module/02-01-SUMMARY.md`
</output>
