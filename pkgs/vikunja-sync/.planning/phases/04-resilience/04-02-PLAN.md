---
phase: 04-resilience
type: execute
---

<objective>
Fix hook exit code check and implement retry queue consumer.

Purpose: Ensure hook failures are detected and failed syncs are eventually retried.
Output: Hooks properly detect failures, systemd timer processes retry queue.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/references/checkpoints.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix hook exit code check</name>
  <files>NixOS module or hook script source</files>
  <action>
  Find the Taskwarrior hook script that calls vikunja-direct.
  It's likely in `/home/rain/nix/` somewhere or configured via NixOS module.

  Current broken pattern:
  ```bash
  printf ... | vikunja-direct hook >> log 2>&1
  if [[ $? -ne 0 ]]; then  # This checks redirect exit code!
  ```

  Fix option 1 (heredoc):
  ```bash
  vikunja-direct hook >> log 2>&1 <<< "$(printf '%s\n%s\n' "$old_task" "$new_task")"
  if [[ $? -ne 0 ]]; then
  ```

  Fix option 2 (PIPESTATUS):
  ```bash
  printf '%s\n%s\n' "$old_task" "$new_task" | vikunja-direct hook >> log 2>&1
  exit_code=${PIPESTATUS[0]}  # Actually gets exit code from printf, need PIPESTATUS[1]
  # Actually: PIPESTATUS array: [0]=printf exit, [1]=vikunja-direct exit
  if [[ ${PIPESTATUS[1]} -ne 0 ]]; then
  ```

  Fix option 3 (set -o pipefail):
  ```bash
  set -o pipefail
  printf '%s\n%s\n' "$old_task" "$new_task" | vikunja-direct hook >> log 2>&1
  if [[ $? -ne 0 ]]; then
  ```

  Preferred: Option 1 (heredoc) is clearest.

  Search for hook scripts:
  ```bash
  find /home/rain/nix -name "*hook*" -type f 2>/dev/null
  grep -r "vikunja-direct hook" /home/rain/nix/
  ```
  </action>
  <verify>Read the hook script to confirm exit code is properly captured</verify>
  <done>Hook script properly checks vikunja-direct exit code, not redirect</done>
</task>

<task type="auto">
  <name>Task 2: Create retry queue consumer script</name>
  <files>vikunja-sync-retry.py (new), vikunja_common.py</files>
  <action>
  Create /home/rain/nix/pkgs/vikunja-sync/vikunja-sync-retry.py:

  ```python
  #!/usr/bin/env python3
  """Process the vikunja-sync retry queue."""
  import os
  import sys
  from pathlib import Path
  from vikunja_common import Config, ConfigError, SyncLogger

  QUEUE_FILE = Path("/tmp/vikunja-sync-queue.txt")

  def main():
      logger = SyncLogger("retry")

      if not QUEUE_FILE.exists():
          logger.debug("No queue file, nothing to retry")
          return 0

      # Read and deduplicate UUIDs
      try:
          content = QUEUE_FILE.read_text()
          uuids = list(dict.fromkeys(line.strip() for line in content.splitlines() if line.strip()))
      except Exception as e:
          logger.error(f"Failed to read queue: {e}")
          return 1

      if not uuids:
          logger.debug("Queue empty")
          QUEUE_FILE.unlink(missing_ok=True)
          return 0

      logger.info(f"Processing {len(uuids)} queued task(s)")

      try:
          config = Config.from_env()
      except ConfigError as e:
          logger.error(f"Config error: {e}")
          return 1

      # Import here to avoid circular dependency
      import subprocess

      failed = []
      for uuid in uuids:
          result = subprocess.run(
              ["vikunja-direct", "push", uuid],
              capture_output=True,
              text=True,
              timeout=60,
          )
          if result.returncode != 0:
              logger.warning(f"Retry failed for {uuid}: {result.stderr}")
              failed.append(uuid)
          else:
              logger.info(f"Retry succeeded for {uuid}")

      # Write back only failed UUIDs
      if failed:
          QUEUE_FILE.write_text("\n".join(failed) + "\n")
          logger.warning(f"{len(failed)} task(s) still failing")
      else:
          QUEUE_FILE.unlink(missing_ok=True)
          logger.info("Queue cleared")

      return 0 if not failed else 1

  if __name__ == "__main__":
      sys.exit(main())
  ```
  </action>
  <verify>python3 -m py_compile vikunja-sync-retry.py</verify>
  <done>vikunja-sync-retry.py created with queue processing logic</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>How should the retry timer be implemented?</decision>
  <context>The retry script needs to run periodically. NixOS provides several options.</context>
  <options>
    <option id="systemd-timer">
      <name>Systemd timer in NixOS module</name>
      <pros>Native NixOS integration, proper service management, logging via journald</pros>
      <cons>Requires modifying NixOS module, more complex</cons>
    </option>
    <option id="cron">
      <name>Cron job via services.cron</name>
      <pros>Simple, familiar, easy to add</pros>
      <cons>Less integrated, separate logging</cons>
    </option>
    <option id="manual">
      <name>Manual only (no automatic retry)</name>
      <pros>Simplest, user controls when to retry</pros>
      <cons>Failed syncs stay failed until user notices</cons>
    </option>
  </options>
  <resume-signal>Select: systemd-timer, cron, or manual</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Hook script properly captures vikunja-direct exit code
- [ ] vikunja-sync-retry.py exists and compiles
- [ ] Retry mechanism configured (based on decision)
- [ ] `cd /home/rain/nix && sudo nixos-rebuild test --flake .#malphas` succeeds

Test retry queue:
```bash
# Add a fake UUID to queue
echo "test-uuid-12345" >> /tmp/vikunja-sync-queue.txt
# Run retry (should fail gracefully for fake UUID)
vikunja-sync-retry
# Queue should be cleared or contain only failed UUIDs
```
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Failed syncs get queued and retried
- NixOS rebuild succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-resilience/04-02-SUMMARY.md`
</output>
