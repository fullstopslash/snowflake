---
phase: 01-critical-fixes
type: execute
---

<objective>
Implement bidirectional tag/label sync - both add AND remove tags/labels when syncing.

Purpose: Currently removing a tag in TW doesn't remove the label in Vikunja (and vice versa), causing permanent drift between systems.
Output: Full bidirectional tag sync: TW tag changes (add/remove) reflect in Vikunja labels, and vice versa.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@vikunja-direct.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add helper functions for fetching and detaching labels</name>
  <files>vikunja-direct.py</files>
  <action>
  Add two helper functions near the existing get_or_create_label function:

  ```python
  def get_vikunja_task(config: Config, task_id: int) -> dict | None:
      """Fetch current state of a Vikunja task."""
      try:
          req = Request(
              f"{config.vikunja_url}/api/v1/tasks/{task_id}",
              headers={"Authorization": f"Bearer {config.api_token}"},
          )
          with urlopen(req, timeout=10) as resp:
              return json.loads(resp.read().decode())
      except (URLError, HTTPError):
          return None

  def detach_label(config: Config, task_id: int, label_id: int) -> bool:
      """Remove a label from a Vikunja task."""
      try:
          req = Request(
              f"{config.vikunja_url}/api/v1/tasks/{task_id}/labels/{label_id}",
              headers={"Authorization": f"Bearer {config.api_token}"},
              method="DELETE",
          )
          with urlopen(req, timeout=10):
              return True
      except HTTPError as e:
          if e.code == 404:
              return True  # Already removed
          log(f"Failed to detach label {label_id} from task {task_id}: {e}")
          return False
      except URLError as e:
          log(f"Network error detaching label: {e}")
          return False
  ```
  </action>
  <verify>Read the file to confirm functions exist with correct signatures</verify>
  <done>get_vikunja_task and detach_label functions added with proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Implement TW->Vikunja label removal in push_to_vikunja</name>
  <files>vikunja-direct.py</files>
  <action>
  In the push_to_vikunja() function, after getting task_id for an existing task update:

  1. Fetch current Vikunja task state:
     ```python
     current_vikunja_task = get_vikunja_task(config, task_id)
     ```

  2. Compute labels to remove (after you've computed labels to add):
     ```python
     if current_vikunja_task:
         current_labels = current_vikunja_task.get("labels") or []
         current_label_titles = {label["title"] for label in current_labels}
         new_label_titles = set(tw_task.get("tags", []))
         labels_to_remove = current_label_titles - new_label_titles

         # Build a map of title -> id for removal
         label_title_to_id = {label["title"]: label["id"] for label in current_labels}

         for title in labels_to_remove:
             label_id = label_title_to_id.get(title)
             if label_id:
                 detach_label(config, task_id, label_id)
     ```

  This should happen AFTER task update but BEFORE/ALONGSIDE label attachment.
  Log the removals: `log(f"Detached {len(labels_to_remove)} label(s) from task {task_id}")`
  </action>
  <verify>Read push_to_vikunja to confirm label removal logic exists</verify>
  <done>push_to_vikunja computes label diff and calls detach_label for removed tags</done>
</task>

<task type="auto">
  <name>Task 3: Implement Vikunja->TW tag removal in handle_webhook</name>
  <files>vikunja-direct.py</files>
  <action>
  In handle_webhook() for task.updated events, when updating an existing TW task:

  1. Get current TW task tags:
     ```python
     current_tw_tags = set(existing_task.get("tags", []))
     new_tags_from_vikunja = set(tw_task.get("tags", []))
     ```

  2. Compute tags to add and remove:
     ```python
     tags_to_add = new_tags_from_vikunja - current_tw_tags
     tags_to_remove = current_tw_tags - new_tags_from_vikunja
     ```

  3. Build args with both additions and removals:
     ```python
     for tag in tags_to_add:
         args.append(f"+{tag}")
     for tag in tags_to_remove:
         args.append(f"-{tag}")
     ```

  Currently the code only does `args.extend(f"+{tag}" for tag in tw_task["tags"])` which only adds.
  </action>
  <verify>Read handle_webhook to confirm tag removal args are added</verify>
  <done>handle_webhook computes tag diff and includes -tag args for removals</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] get_vikunja_task and detach_label helper functions exist
- [ ] push_to_vikunja fetches current labels, computes diff, calls detach_label for removals
- [ ] handle_webhook computes tag diff and adds -tag args for removals
- [ ] `cd /home/rain/nix && sudo nixos-rebuild test --flake .#malphas` succeeds

Manual test after rebuild:
```bash
# Test TW -> Vikunja removal
task add "bidirectional test" project:Test +tag1 +tag2
sleep 2
task <id> modify -tag1
sleep 2
# Verify in Vikunja API: task should only have tag2 label
```
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Bidirectional tag sync works in both directions
- NixOS rebuild succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fixes/01-02-SUMMARY.md`
</output>
