---
phase: 01-critical-fixes
type: execute
---

<objective>
Fix subprocess return code checks in vikunja-direct.py to properly report failures.

Purpose: Task deletions, modifications, and completions currently report success even when they fail, causing silent data corruption.
Output: All subprocess.run() calls check return codes and report failures appropriately.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@vikunja-direct.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix task deletion return code check</name>
  <files>vikunja-direct.py</files>
  <action>
  Find the subprocess.run() call for task deletion (around line 208, the one with "delete" and input="yes\n").

  Current pattern:
  ```python
  subprocess.run(["task", existing_uuid, "delete"], input="yes\n", ...)
  log(f"Deleted TW task: {existing_uuid}")
  return {"success": True, ...}  # Always returns success!
  ```

  Fix to:
  ```python
  result = subprocess.run(["task", existing_uuid, "delete"], input="yes\n", capture_output=True, text=True, env=SYNC_ENV, timeout=30)
  if result.returncode != 0:
      log(f"Failed to delete TW task {existing_uuid}: {result.stderr}")
      return {"success": False, "action": "delete_failed", "uuid": existing_uuid, "error": result.stderr}
  log(f"Deleted TW task: {existing_uuid}")
  return {"success": True, ...}
  ```

  Add timeout=30 to prevent hung processes.
  </action>
  <verify>Read the modified code section to confirm return code is checked</verify>
  <done>Delete subprocess call captures result, checks returncode, returns failure dict on non-zero exit</done>
</task>

<task type="auto">
  <name>Task 2: Fix task modify return code check</name>
  <files>vikunja-direct.py</files>
  <action>
  Find the subprocess.run() call for task modification (around line 236, the one building args list with "task", uuid, "modify").

  Apply same pattern:
  1. Capture the result: `result = subprocess.run(args, ...)`
  2. Check return code: `if result.returncode != 0:`
  3. Log error and return failure response
  4. Add timeout=30

  Make sure to preserve the existing logic flow - only modify the subprocess handling.
  </action>
  <verify>Read the modified code section to confirm return code is checked</verify>
  <done>Modify subprocess call checks returncode and returns appropriate failure/success</done>
</task>

<task type="auto">
  <name>Task 3: Fix task done return code check</name>
  <files>vikunja-direct.py</files>
  <action>
  Find the subprocess.run() call for marking tasks done (around lines 240-244, the one with "done").

  Apply same pattern:
  1. Capture the result
  2. Check return code
  3. Don't report success if it failed
  4. Add timeout=30

  This is critical because marking a task done when the command failed leaves TW and Vikunja out of sync.
  </action>
  <verify>Read the modified code section to confirm return code is checked</verify>
  <done>Done subprocess call checks returncode and only reports success on success</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] All three subprocess.run() calls (delete, modify, done) capture result and check returncode
- [ ] All three have timeout=30 parameter
- [ ] Failure cases return {"success": False, ...} with error details
- [ ] `cd /home/rain/nix && sudo nixos-rebuild test --flake .#malphas` succeeds
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Code compiles/runs without syntax errors
- NixOS rebuild succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fixes/01-01-SUMMARY.md`
</output>
