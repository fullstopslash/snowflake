---
phase: 19-host-discovery-elegance
plan: 01
type: execute
---

<objective>
Make host behavior declarative in host configs instead of hardcoded in flake mkHost function.

Purpose: Eliminate hardcoded testVMs lists, architecture assumptions, and nixpkgs variant logic from mkHost. Host files should declare their own behavior explicitly, making the system easier to understand and maintain.

Output: Declarative host configs, simplified mkHost, auto-discovering installer with helper script.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@flake.nix
@nixos-installer/flake.nix
@modules/common/host-spec.nix
@hosts/griefling/default.nix
@hosts/malphas/default.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add host behavior options to host-spec module</name>
  <files>modules/common/host-spec.nix, roles/form-desktop.nix, roles/form-vm.nix, roles/form-laptop.nix, roles/form-server.nix, roles/form-pi.nix</files>
  <action>
Add three new options to modules/common/host-spec.nix in the IDENTITY section:

1. `architecture` (string): System architecture (x86_64-linux, aarch64-linux, x86_64-darwin). No default - must be set by roles or hosts.

2. `nixpkgsVariant` (enum: "stable" | "unstable"): Which nixpkgs input to use. Default "stable".

3. `useCustomPkgs` (bool): Whether to use alternate nixpkgs with custom config. Derived from nixpkgsVariant != "stable". Default false.

Set defaults in role files:
- roles/form-desktop.nix: architecture = lib.mkDefault "x86_64-linux", nixpkgsVariant = lib.mkDefault "stable"
- roles/form-vm.nix: architecture = lib.mkDefault "x86_64-linux", nixpkgsVariant = lib.mkDefault "unstable" (VMs use unstable for testing)
- roles/form-laptop.nix: architecture = lib.mkDefault "x86_64-linux"
- roles/form-server.nix: architecture = lib.mkDefault "x86_64-linux"
- roles/form-pi.nix: architecture = lib.mkDefault "aarch64-linux"

Also extend the `disks` config (already exists in hosts) to include everything installer needs - no new options needed, just verify it has: enable, layout, device, withSwap, swapSize.

AVOID adding these to hostSpec behavioral section - they belong in IDENTITY as they define what the host IS, not how it behaves.
  </action>
  <verify>
- nix eval .#nixosConfigurations.griefling.config.hostSpec.architecture returns value
- nix eval .#nixosConfigurations.griefling.config.hostSpec.nixpkgsVariant returns value
- No evaluation errors when checking any host config
  </verify>
  <done>Host behavior options exist, roles set sensible defaults, no eval errors</done>
</task>

<task type="auto">
  <name>Task 2: Simplify mkHost to read behavior from config</name>
  <files>flake.nix</files>
  <action>
Refactor the mkHost function (lines 32-108) to:

1. Remove hardcoded testVMs list (lines 44-48). This should come from config.hostSpec.nixpkgsVariant instead.

2. Read architecture from host config instead of hardcoding to "x86_64-linux". Use a two-pass evaluation:
   - First pass: Evaluate host config with stub specialArgs to read hostSpec.architecture
   - Use that architecture for final nixosSystem call
   - If architecture not set, fail with clear error message

3. Read nixpkgsVariant from host config to determine pkgInput:
   - If "unstable" → use inputs.nixpkgs-unstable
   - If "stable" → use nixpkgs
   - Create customPkgs only if nixpkgsVariant != "stable"

4. Create hostLib based on pkgInput (extend with lib.custom regardless of variant)

5. Keep the specialArgs structure but derive isDarwin from architecture string (contains "darwin")

The goal: mkHost should be a thin wrapper that reads host config and wires up nixpkgs accordingly. No hardcoded host-specific logic.

AVOID using builtins.elem or hardcoded lists of hostnames - everything should be declarative from host config.
  </action>
  <verify>
- nix flake check passes (all hosts evaluate correctly)
- nix build .#nixosConfigurations.griefling.config.system.build.toplevel succeeds
- nix build .#nixosConfigurations.malphas.config.system.build.toplevel succeeds
- grep -q "testVMs\|griefling\|sorrow\|torment" flake.nix returns no matches (hardcoded names removed)
  </verify>
  <done>mkHost reads behavior from config, no hardcoded hostnames, all hosts build successfully</done>
</task>

<task type="auto">
  <name>Task 3: Auto-discover installer hosts and create install-host helper</name>
  <files>nixos-installer/flake.nix, nixos-installer/install-host.sh, nixos-installer/minimal-configuration.nix</files>
  <action>
1. Update nixos-installer/flake.nix:
   - Remove manual nixosConfigurations declarations (lines 68-73)
   - Auto-discover hosts from ../hosts/ using builtins.readDir (same pattern as root flake lines 123-134)
   - Filter out: TEMPLATE.nix, template/, iso/
   - For each discovered host, read its config to get: disks.device, disks.swapSize, disks.layout
   - Map disks.layout to diskSpecPath:
     * "btrfs-luks-impermanence" → btrfs-luks-impermanence-disk.nix
     * "btrfs-impermanence" → btrfs-impermanence-disk.nix
     * "btrfs" → btrfs-disk.nix
   - Use hostSpec.architecture from host config for system value
   - Pass disk, swapSize, withSwap as module args (read from disks config)

2. Create nixos-installer/install-host.sh script:
   ```bash
   #!/usr/bin/env bash
   set -euo pipefail

   HOSTNAME="${1:-}"
   if [ -z "$HOSTNAME" ]; then
     echo "Usage: install-host <hostname>"
     echo "Available hosts:"
     ls /etc/nixos-config/hosts/ | grep -v TEMPLATE | grep -v template | grep -v iso
     exit 1
   fi

   echo "Installing host: $HOSTNAME"
   echo "This will:"
   echo "  1. Partition and format disks with disko"
   echo "  2. Install NixOS configuration"
   echo "  3. Reboot (secrets must be bootstrapped after first boot)"
   echo ""
   read -p "Continue? (y/N) " -n 1 -r
   echo
   if [[ ! $REPLY =~ ^[Yy]$ ]]; then
     exit 1
   fi

   nixos-install --flake /etc/nixos-config#$HOSTNAME --no-root-password

   echo ""
   echo "Installation complete!"
   echo "After reboot, run: /path/to/nix-config/scripts/bootstrap-secrets.sh $HOSTNAME"
   ```

3. Make script executable and add to minimal-configuration.nix:
   - Copy script to /usr/local/bin/install-host in ISO
   - Add to bash history: echo "install-host " >> /root/.bash_history
   - Include troubleshooting tools: neovim, btrfs-progs, bcachefs-tools

AVOID embedding nix-secrets in ISO (security risk). Secrets are bootstrapped post-install.
  </action>
  <verify>
- nix flake check --flake ./nixos-installer passes
- nixos-installer/install-host.sh exists and is executable
- Script shows usage message when run without args
- Auto-discovery finds griefling and malphas hosts
  </verify>
  <done>Installer auto-discovers hosts, install-host script works, ISO will have convenient install command</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All hosts evaluate: nix flake check passes
- [ ] griefling builds: nix build .#nixosConfigurations.griefling.config.system.build.toplevel
- [ ] malphas builds: nix build .#nixosConfigurations.malphas.config.system.build.toplevel
- [ ] No hardcoded hostname lists remain in flake.nix
- [ ] nixos-installer auto-discovers hosts correctly
- [ ] install-host script is functional
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- mkHost is simplified and declarative
- Host behavior is explicit in host configs
- Installer auto-discovers hosts
- No hardcoded host-specific logic in flakes
</success_criteria>

<output>
After completion, create `.planning/phases/19-host-discovery-elegance/19-01-SUMMARY.md`:

# Phase 19 Plan 1: Declarative Host Behavior Summary

**[One-line summary of what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- `file/path` - Description

## Decisions Made
[Key decisions and rationale, or "None"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 19-02-PLAN.md (Rename hostSpec → host)
</output>
