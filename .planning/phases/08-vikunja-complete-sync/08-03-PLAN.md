---
phase: 08-vikunja-complete-sync
plan: 03
type: execute
---

<objective>
Ensure TW hooks survive NixOS rebuilds, add self-validation, and implement a diagnostic command for debugging sync issues.

Purpose: The hooks installed by NixOS activation scripts can become stale or broken after rebuilds. This plan adds validation and self-healing capabilities to ensure continuous operation.

Output: Enhanced hook activation with validation, plus a diagnostic CLI command.
</objective>

<context>
@.planning/ROADMAP.md
@.planning/phases/08-vikunja-complete-sync/08-01-PLAN.md
@.planning/phases/08-vikunja-complete-sync/08-02-PLAN.md
@roles/vikunja-sync.nix
@pkgs/vikunja-sync/vikunja-direct.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hook validation to activation script</name>
  <files>roles/vikunja-sync.nix</files>
  <action>
Enhance the activation script to validate hook symlinks and report issues.

Current activation script (around line 471-490) creates symlinks. Add validation:

```nix
system.activationScripts.vikunja-sync-hook = {
  text =
    if cfg.enableDirectSync
    then ''
      HOOK_DIR="${homeDir}/.config/task/hooks"
      mkdir -p "$HOOK_DIR"

      # Remove old/unused hooks
      rm -f "$HOOK_DIR/on-exit-vikunja"
      rm -f "$HOOK_DIR/on-delete-vikunja"

      # Install on-add and on-modify hooks for direct sync
      ln -sf /etc/vikunja-sync-hook/on-add-vikunja "$HOOK_DIR/on-add-vikunja"
      ln -sf /etc/vikunja-sync-hook/on-modify-vikunja "$HOOK_DIR/on-modify-vikunja"
      chown -h ${username}:users "$HOOK_DIR/on-add-vikunja" "$HOOK_DIR/on-modify-vikunja"

      # Validate hooks are correctly linked and executable
      ERRORS=0
      for hook in on-add-vikunja on-modify-vikunja; do
        TARGET=$(readlink -f "$HOOK_DIR/$hook" 2>/dev/null)
        if [ ! -x "$TARGET" ]; then
          echo "WARNING: Hook $hook not executable or missing: $TARGET" >&2
          ERRORS=$((ERRORS + 1))
        fi
      done

      # Check if vikunja-direct is in PATH
      if ! command -v vikunja-direct >/dev/null 2>&1; then
        echo "WARNING: vikunja-direct not found in PATH" >&2
        ERRORS=$((ERRORS + 1))
      fi

      if [ $ERRORS -gt 0 ]; then
        echo "vikunja-sync: $ERRORS validation warnings" >&2
      else
        echo "vikunja-sync: hooks validated successfully"
      fi
    ''
    else # ... existing fallback code
```

This adds runtime validation during rebuild.

AVOID: Don't fail the activation on warnings - just report them.
  </action>
  <verify>Rebuild system, check for validation messages in output</verify>
  <done>Activation script includes hook validation with warnings</done>
</task>

<task type="auto">
  <name>Task 2: Add vikunja-direct diagnose command</name>
  <files>pkgs/vikunja-sync/vikunja-direct.py</files>
  <action>
Add a `diagnose` CLI command to check sync system health:

```python
def cmd_diagnose(_args: list[str]) -> int:
    """Diagnose vikunja-sync system health."""
    import shutil
    from pathlib import Path

    errors = 0
    warnings = 0

    print("=== Vikunja Sync Diagnostics ===\n")

    # 1. Check environment variables
    print("Environment:")
    for var in ["VIKUNJA_URL", "VIKUNJA_API_TOKEN_FILE", "VIKUNJA_USER"]:
        val = os.environ.get(var, "")
        if val:
            if "TOKEN" in var or "PASS" in var:
                print(f"  {var}: [set]")
            else:
                print(f"  {var}: {val}")
        else:
            print(f"  {var}: NOT SET")
            errors += 1

    # 2. Check token file readability
    token_file = os.environ.get("VIKUNJA_API_TOKEN_FILE")
    if token_file:
        try:
            Path(token_file).read_text()
            print(f"\nToken file: readable")
        except Exception as e:
            print(f"\nToken file: ERROR - {e}")
            errors += 1

    # 3. Check TW hooks
    print("\nTaskwarrior hooks:")
    hook_dir = Path.home() / ".config" / "task" / "hooks"
    for hook in ["on-add-vikunja", "on-modify-vikunja"]:
        hook_path = hook_dir / hook
        if hook_path.is_symlink():
            target = hook_path.resolve()
            if target.exists() and os.access(target, os.X_OK):
                print(f"  {hook}: OK -> {target}")
            else:
                print(f"  {hook}: BROKEN -> {target}")
                errors += 1
        elif hook_path.exists():
            print(f"  {hook}: OK (regular file)")
        else:
            print(f"  {hook}: MISSING")
            errors += 1

    # 4. Check required binaries
    print("\nBinaries:")
    for binary in ["task", "jaq", "curl"]:
        path = shutil.which(binary)
        if path:
            print(f"  {binary}: {path}")
        else:
            print(f"  {binary}: NOT FOUND")
            errors += 1

    # 5. Check state directory
    state_dir = get_state_dir()
    print(f"\nState directory: {state_dir}")
    queue_file = state_dir / "queue.txt"
    if queue_file.exists():
        count = len(queue_file.read_text().strip().split("\n"))
        print(f"  Queue file: {count} pending items")
        if count > 0:
            warnings += 1
    else:
        print(f"  Queue file: empty")

    lock_file = state_dir / "direct.lock"
    print(f"  Lock file: {'exists' if lock_file.exists() else 'not present'}")

    # 6. Test API connectivity
    print("\nAPI connectivity:")
    try:
        config = Config.from_env()
        vikunja = VikunjaClient(config)
        projects = vikunja.get("/projects")
        if projects:
            print(f"  Vikunja API: OK ({len(projects)} projects)")
        else:
            print(f"  Vikunja API: ERROR (no projects returned)")
            errors += 1
    except ConfigError as e:
        print(f"  Vikunja API: CONFIG ERROR - {e}")
        errors += 1
    except Exception as e:
        print(f"  Vikunja API: ERROR - {e}")
        errors += 1

    # Summary
    print(f"\n=== Summary ===")
    print(f"Errors: {errors}")
    print(f"Warnings: {warnings}")

    return 1 if errors > 0 else 0
```

Add to main():
```python
elif cmd == "diagnose":
    return cmd_diagnose(args)
```

AVOID: Don't expose actual token values in output.
  </action>
  <verify>vikunja-direct diagnose runs and shows system health</verify>
  <done>Diagnostic command added for health checks</done>
</task>

<task type="auto">
  <name>Task 3: Add hook self-test on first run after boot</name>
  <files>roles/vikunja-sync.nix</files>
  <action>
Add a systemd user service that runs diagnostics on login/boot:

```nix
# Self-test service runs on user login
systemd.user.services.vikunja-sync-selftest = lib.mkIf cfg.enableDirectSync {
  description = "Vikunja Sync Self-Test";
  wantedBy = ["default.target"];
  after = ["network-online.target"];

  serviceConfig = {
    Type = "oneshot";
    RemainAfterExit = true;
    ExecStart = "${pkgs.bash}/bin/bash -c '${vikunjaSync}/bin/vikunja-direct diagnose || echo \"vikunja-sync: self-test found issues\"'";
  };

  environment = {
    VIKUNJA_URL = cfg.vikunjaUrl;
    VIKUNJA_USER = cfg.caldavUser;
    VIKUNJA_API_TOKEN_FILE = config.sops.secrets."caldav/vikunja-api".path;
  };
};
```

This runs the diagnose command at login to catch issues early.

AVOID: Don't fail the service on diagnostic errors - just log them.
AVOID: Don't run on every service start - use RemainAfterExit.
  </action>
  <verify>After rebuild, check: systemctl --user status vikunja-sync-selftest</verify>
  <done>Self-test service runs at login</done>
</task>

<task type="auto">
  <name>Task 4: Add queue cleanup and reporting to diagnose</name>
  <files>pkgs/vikunja-sync/vikunja-direct.py</files>
  <action>
Enhance the diagnose command to show queue details and offer cleanup:

Add after the queue check section:

```python
# Show queue contents if any
if queue_file.exists():
    print("\nQueued task UUIDs:")
    for line in queue_file.read_text().strip().split("\n"):
        if line.strip():
            print(f"    {line.strip()}")
    print("\n  Run 'vikunja-direct process-queue' to retry these tasks")
```

Also add a `process-queue` command:

```python
def cmd_process_queue(_args: list[str]) -> int:
    """Process the retry queue manually."""
    queue_file = get_state_dir() / "queue.txt"
    if not queue_file.exists():
        print("Queue is empty")
        return 0

    try:
        config = Config.from_env()
    except ConfigError as e:
        log(f"Config error: {e}")
        return 1

    default_project = os.environ.get("VIKUNJA_DEFAULT_PROJECT", "inbox")
    tw = TaskwarriorClient()

    uuids = [u.strip() for u in queue_file.read_text().strip().split("\n") if u.strip()]
    processed = 0
    failed = []

    for uuid in set(uuids):  # Dedupe
        task = tw.export_task(uuid)
        if not task:
            log(f"Task {uuid} not found in TW, skipping")
            continue

        result = push_to_vikunja(task, config, default_project)
        if result["success"]:
            processed += 1
            log(f"Synced {uuid}: {result['action']}")
        else:
            failed.append(uuid)
            log(f"Failed {uuid}: {result['action']}")

    # Update queue file with only failed UUIDs
    if failed:
        queue_file.write_text("\n".join(failed) + "\n")
    else:
        queue_file.unlink()

    print(f"Processed: {processed}, Failed: {len(failed)}")
    return 0 if not failed else 1
```

Add to main():
```python
elif cmd == "process-queue":
    return cmd_process_queue(args)
```

AVOID: Don't process tasks that no longer exist in TW.
  </action>
  <verify>vikunja-direct process-queue works with queued items</verify>
  <done>Queue processing command added</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python3 -m py_compile pkgs/vikunja-sync/vikunja-direct.py` passes
- [ ] `nh os switch .` completes with hook validation output
- [ ] `vikunja-direct diagnose` shows comprehensive system health
- [ ] `vikunja-direct process-queue` processes queued items
- [ ] Self-test service runs at login
</verification>

<success_criteria>
- All tasks completed
- Python syntax valid
- Hook validation runs during system activation
- Diagnostic command provides actionable information
- Queue can be manually processed for recovery
</success_criteria>

<output>
After completion, create `.planning/phases/08-vikunja-complete-sync/08-03-SUMMARY.md`
</output>
