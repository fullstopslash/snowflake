---
phase: 09-vikunja-sync-fixes
plan: 04
title: Circuit Breaker for API Resilience
status: pending
---

# Plan 09-04: Circuit Breaker for API Resilience

Fix HIGH priority issue #5: Unbounded API retries block webhook processing during Vikunja outages.

## Goal

Implement a circuit breaker pattern that fails fast after detecting API unavailability, queuing tasks for retry instead of blocking.

## Context

### The Problem

Current retry behavior in `vikunja_common.py`:

```python
for attempt in range(self.max_retries):  # 3 attempts
    # ...
    time.sleep(2**attempt)  # 1s, 2s, 4s = 7 seconds total
```

During a Vikunja outage:
1. Every webhook blocks for 7+ seconds
2. systemd timeout (60s) eventually kills the service
3. Multiple webhooks queue up, each blocking
4. System becomes unresponsive

### Circuit Breaker Pattern

A circuit breaker tracks failures and "opens" after a threshold, causing immediate failures without attempting the request:

```
CLOSED (normal) -> OPEN (after N failures) -> HALF-OPEN (test) -> CLOSED
```

## Changes

### File: `pkgs/vikunja-sync/vikunja_common.py`

#### 1. Add CircuitBreaker class

```python
import time
from dataclasses import dataclass, field
from pathlib import Path
from threading import Lock

@dataclass
class CircuitBreaker:
    """Simple circuit breaker for API resilience."""

    failure_threshold: int = 3
    recovery_timeout: int = 60  # seconds
    _failures: int = field(default=0, init=False)
    _last_failure_time: float = field(default=0.0, init=False)
    _state: str = field(default="closed", init=False)
    _lock: Lock = field(default_factory=Lock, init=False)

    def _get_state_file(self) -> Path:
        """Get persistent state file path."""
        home = os.environ.get("HOME", os.path.expanduser("~"))
        state_dir = Path(home) / ".local" / "state" / "vikunja-sync"
        state_dir.mkdir(parents=True, exist_ok=True)
        return state_dir / "circuit_breaker.json"

    def _load_state(self) -> None:
        """Load state from file (for cross-process sharing)."""
        state_file = self._get_state_file()
        if state_file.exists():
            try:
                import json
                data = json.loads(state_file.read_text())
                self._failures = data.get("failures", 0)
                self._last_failure_time = data.get("last_failure_time", 0.0)
                self._state = data.get("state", "closed")
            except (json.JSONDecodeError, KeyError):
                pass

    def _save_state(self) -> None:
        """Save state to file."""
        import json
        state_file = self._get_state_file()
        state_file.write_text(json.dumps({
            "failures": self._failures,
            "last_failure_time": self._last_failure_time,
            "state": self._state,
        }))

    def allow_request(self) -> bool:
        """Check if request should be allowed."""
        with self._lock:
            self._load_state()

            if self._state == "closed":
                return True

            if self._state == "open":
                # Check if recovery timeout has passed
                if time.time() - self._last_failure_time > self.recovery_timeout:
                    self._state = "half-open"
                    self._save_state()
                    return True  # Allow one test request
                return False

            # half-open: allow request (testing recovery)
            return True

    def record_success(self) -> None:
        """Record successful request."""
        with self._lock:
            self._failures = 0
            self._state = "closed"
            self._save_state()

    def record_failure(self) -> None:
        """Record failed request."""
        with self._lock:
            self._failures += 1
            self._last_failure_time = time.time()

            if self._failures >= self.failure_threshold:
                self._state = "open"

            self._save_state()

    def is_open(self) -> bool:
        """Check if circuit is open (blocking requests)."""
        with self._lock:
            self._load_state()
            return self._state == "open"
```

#### 2. Integrate into VikunjaClient

```python
class VikunjaClient:
    """HTTP client for Vikunja API."""

    # Shared circuit breaker across all instances
    _circuit_breaker: CircuitBreaker | None = None

    def __init__(
        self,
        config: Config,
        timeout: int = 30,
        max_retries: int = 3,
        logger: SyncLogger | None = None,
        use_circuit_breaker: bool = True,
    ):
        self.config = config
        self.timeout = timeout
        self.max_retries = max_retries
        self.logger = logger
        self._label_cache: dict[str, int] = {}
        self.use_circuit_breaker = use_circuit_breaker

        # Initialize shared circuit breaker
        if use_circuit_breaker and VikunjaClient._circuit_breaker is None:
            VikunjaClient._circuit_breaker = CircuitBreaker()

    def _request(
        self, method: str, endpoint: str, data: dict | None = None
    ) -> dict | list | None:
        """Make HTTP request with circuit breaker and retry."""

        # Check circuit breaker first
        if self.use_circuit_breaker and VikunjaClient._circuit_breaker:
            if not VikunjaClient._circuit_breaker.allow_request():
                if self.logger:
                    self.logger.warning(f"Circuit breaker open, skipping {endpoint}")
                raise CircuitBreakerOpen("API circuit breaker is open")

        url = f"{self.config.vikunja_url}/api/v1{endpoint}"
        headers = {"Authorization": f"Bearer {self.config.api_token}"}

        # ... existing request code ...

        try:
            # ... make request ...
            if self.use_circuit_breaker and VikunjaClient._circuit_breaker:
                VikunjaClient._circuit_breaker.record_success()
            return result
        except (HTTPError, URLError) as e:
            if self.use_circuit_breaker and VikunjaClient._circuit_breaker:
                VikunjaClient._circuit_breaker.record_failure()
            raise


class CircuitBreakerOpen(Exception):
    """Raised when circuit breaker is open."""
    pass
```

### File: `pkgs/vikunja-sync/vikunja-direct.py`

#### 3. Handle circuit breaker in push operations

```python
from vikunja_common import CircuitBreakerOpen

def push_to_vikunja(tw_task: dict, config: Config, default_project: str = "inbox") -> dict:
    """Push a Taskwarrior task to Vikunja API."""
    try:
        vikunja = VikunjaClient(config)
        # ... existing code ...
    except CircuitBreakerOpen:
        log("Circuit breaker open, queueing for retry")
        return {"success": False, "action": "circuit_breaker_open", "vikunja_id": None}
```

#### 4. Add diagnose command for circuit breaker status

```python
def cmd_diagnose(_args: list[str]) -> int:
    # ... existing checks ...

    # Check circuit breaker status
    print("\nCircuit breaker:")
    from vikunja_common import CircuitBreaker
    cb = CircuitBreaker()
    cb._load_state()
    if cb._state == "open":
        print(f"  Status: OPEN (failing fast)")
        print(f"  Failures: {cb._failures}")
        recovery_in = cb.recovery_timeout - (time.time() - cb._last_failure_time)
        print(f"  Recovery in: {max(0, int(recovery_in))}s")
        warnings += 1
    elif cb._state == "half-open":
        print("  Status: HALF-OPEN (testing)")
    else:
        print("  Status: CLOSED (normal)")
```

## Configuration

Default thresholds:
- **failure_threshold**: 3 consecutive failures to open
- **recovery_timeout**: 60 seconds before attempting recovery

These can be made configurable via environment variables if needed.

## Verification

1. **Open test**: Disconnect Vikunja, trigger 3 webhooks, verify circuit opens
2. **Recovery test**: After 60s, verify circuit allows one test request
3. **Success reset**: After successful request, verify failures reset to 0
4. **Diagnose**: Verify `vikunja-direct diagnose` shows circuit status

## Checklist

- [ ] Add `CircuitBreaker` class to `vikunja_common.py`
- [ ] Add `CircuitBreakerOpen` exception
- [ ] Integrate circuit breaker into `VikunjaClient._request()`
- [ ] Handle `CircuitBreakerOpen` in `push_to_vikunja()` and `handle_webhook()`
- [ ] Add circuit breaker status to `cmd_diagnose()`
- [ ] Verify NixOS rebuild succeeds
- [ ] Manual test: disconnect Vikunja, verify fast failures

## Rollback

Set `use_circuit_breaker=False` when instantiating `VikunjaClient` to disable.
