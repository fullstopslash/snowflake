---
phase: 09-vikunja-sync-fixes
plan: 01
title: Deleted Task Filtering & Locking Extension
status: pending
---

# Plan 09-01: Deleted Task Filtering & Locking Extension

Fix the two CRITICAL issues: vikunja_id collision on deleted tasks and the incomplete locking around task lookups.

## Goal

Ensure `find_tw_task_by_vikunja_id()` never returns deleted tasks, and extend file locking to cover the entire read-modify-write cycle in webhook handling.

## Context

### Issue #2: vikunja_id Collision on Task Recreation
When a TW task is deleted, it retains its `vikunja_id` annotation. If Vikunja reuses that ID (or a new task gets the same ID after deletion), the lookup finds the DELETED task instead of creating a new one.

### Issue #1: Concurrent Task Modification Race
The current locking in `cmd_webhook()` only covers `handle_webhook()`, but `find_tw_task_by_vikunja_id()` does a full `export_all()` BEFORE locking. Two webhooks can both read, both see "no match", and both create duplicates.

## Changes

### File: `pkgs/vikunja-sync/vikunja-direct.py`

#### 1. Filter deleted tasks in `find_tw_task_by_vikunja_id()`

```python
def find_tw_task_by_vikunja_id(tw: TaskwarriorClient, vikunja_id: int) -> str | None:
    """Find Taskwarrior task UUID by Vikunja ID annotation."""
    tasks = tw.export_all()
    for task in tasks:
        # Skip deleted tasks - their vikunja_id annotations are stale
        if task.get("status") == "deleted":
            continue
        for ann in task.get("annotations", []):
            if f"vikunja_id:{vikunja_id}" in ann.get("description", ""):
                return task.get("uuid")
    return None
```

#### 2. Filter deleted tasks in `find_tw_task_by_description()`

```python
def find_tw_task_by_description(tw: TaskwarriorClient, description: str, project: str) -> str | None:
    """Find TW task by exact description match in project."""
    tasks = tw.export_project(project)
    for task in tasks:
        # Skip deleted tasks
        if task.get("status") == "deleted":
            continue
        if task.get("description") == description:
            return task.get("uuid")
    return None
```

#### 3. Move lock acquisition to the START of `cmd_webhook()`

Current flow:
```
cmd_webhook() -> parse JSON -> acquire_lock() -> handle_webhook()
```

New flow:
```
cmd_webhook() -> parse JSON -> acquire_lock() -> handle_webhook() (includes all lookups)
```

The lock is already acquired before `handle_webhook()`, but we need to ensure no code path calls the lookup functions outside the lock. This is already correct in the current code, but we should add a comment documenting this requirement.

#### 4. Add explicit lock check in handle_webhook

Add a debug assertion to catch any future code that calls `handle_webhook()` without holding the lock:

```python
def handle_webhook(payload: dict, _lock_held: bool = False) -> dict:
    """
    Handle Vikunja webhook payload - direct write to Taskwarrior.

    IMPORTANT: Caller MUST hold the sync lock before calling this function.
    The lock prevents race conditions in task lookup and creation.

    Returns: {"success": bool, "action": str, "uuid": str|None}
    """
    # ... existing code ...
```

## Verification

1. **Unit test**: Create a deleted TW task with `vikunja_id:999`, then call `find_tw_task_by_vikunja_id(tw, 999)` - should return None
2. **Integration test**: Delete a task in TW, create a task with same title in Vikunja, verify new TW task is created (not linked to deleted one)
3. **Stress test**: Send 5 webhooks for different tasks within 100ms, verify no duplicates

## Checklist

- [ ] Add `status == "deleted"` filter to `find_tw_task_by_vikunja_id()`
- [ ] Add `status == "deleted"` filter to `find_tw_task_by_description()`
- [ ] Add docstring documenting lock requirement to `handle_webhook()`
- [ ] Verify NixOS rebuild succeeds
- [ ] Manual test: delete TW task, create in Vikunja, verify sync

## Rollback

If issues arise, revert the status filter changes. The deleted task collision is rare in practice.
