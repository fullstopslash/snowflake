---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Consolidate lib helpers and clean up overlays for a unified, maintainable package system.

Purpose: Merge the best of both repos' lib and overlay patterns into a single coherent system.
Output: Clean lib/default.nix with useful helpers, consolidated overlays/default.nix with stable/unstable access.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@lib/default.nix
@overlays/default.nix
@flake.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clean up and extend lib helpers</name>
  <files>lib/default.nix</files>
  <action>
Review and update lib/default.nix:

1. Keep existing helpers:
   - relativeToRoot (useful for path references)
   - scanPaths (useful for auto-importing modules)

2. Add helpers useful for the role-based system (prepare for Phase 2):
   ```nix
   # Import all .nix files from a directory (for roles)
   importDir = path:
     map (f: import (path + "/${f}"))
       (builtins.filter (f: lib.hasSuffix ".nix" f && f != "default.nix")
         (builtins.attrNames (builtins.readDir path)));

   # Check if a path exists
   pathExists = path: builtins.pathExists path;
   ```

3. Ensure the lib extension in flake.nix properly exposes lib.custom.

Do NOT over-engineer - keep it minimal. Only add helpers that will actually be used.
  </action>
  <verify>nix eval .#lib.custom.scanPaths --apply 'f: f ./modules' returns list of paths</verify>
  <done>lib/default.nix has clean, useful helpers; lib.custom accessible from flake</done>
</task>

<task type="auto">
  <name>Task 2: Consolidate and clean overlays</name>
  <files>overlays/default.nix</files>
  <action>
Clean up overlays/default.nix:

1. Keep the good patterns:
   - stable-packages overlay (pkgs.stable.*)
   - unstable-packages overlay (pkgs.unstable.*)
   - additions overlay for custom packages from pkgs/

2. Remove or fix broken modifications:
   - The hyprland override is broken (overrideAttrs with wrong args)
   - The steam override is similarly broken
   - Either fix them properly or remove them entirely

3. Fix the hyprland/steam overrides if keeping:
   ```nix
   # Correct pattern for using stable package:
   hyprland = final.stable.hyprland;
   # OR for mesa override:
   hyprland = prev.hyprland.override { mesa = final.unstable.mesa; };
   ```

4. Ensure the overlay is applied correctly in flake.nix nixosConfigurations.

5. Remove linuxModifications if it's not doing anything (currently empty mkIf).

Keep the structure simple. Overlays should be:
- additions: custom packages
- stable-packages: access to stable nixpkgs
- unstable-packages: access to unstable nixpkgs
- modifications: only if actually needed for specific fixes
  </action>
  <verify>nix eval .#packages.x86_64-linux --json | jq 'keys' shows custom packages</verify>
  <done>Overlays are clean, no broken overrides, stable/unstable access works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `nix flake check --no-build` passes
- [ ] `nix eval .#lib.custom` returns the custom lib attrset
- [ ] Overlays don't cause evaluation errors
- [ ] pkgs.stable and pkgs.unstable are accessible in host configurations
</verification>

<success_criteria>
- lib/default.nix has useful helpers without bloat
- overlays/default.nix is clean with no broken overrides
- stable and unstable package access works
- Custom packages from pkgs/ are still exposed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
