# Phase 30, Plan 1: Dynamic Cache Resolution

## Objective

Fix ISO installer and VM test environments to gracefully resolve and use the waterbug.lan binary cache, with automatic fallback when the cache is unavailable. The solution must handle dynamic IP changes, network variations, and gracefully degrade to cache.nixos.org when waterbug is unreachable.

**Why this matters:** Currently the ISO fails to use the local cache due to DNS resolution failures in QEMU environments and lacks graceful fallback, causing slow installations that always hit cache.nixos.org even when a fast local cache is available.

## Context

Current state (read these files):
- @modules/common/build-cache.nix - Hardcoded `waterbug.lan:9999` URL
- @hosts/iso/default.nix - Enables buildCache unconditionally
- @scripts/test-fresh-install.sh - VM test script (currently broken)

**Problem:** The ISO installer and VM test environments cannot resolve `waterbug.lan` because:
1. QEMU user-mode networking doesn't support mDNS/Avahi for `.lan` domains
2. The IP address of waterbug may change over time as the network changes
3. waterbug may not be available on all networks (e.g., laptop on-the-go)

**Requirements:**
- Dynamic runtime resolution of waterbug.lan → actual IP
- Graceful fallback to cache.nixos.org if waterbug unreachable
- No hardcoded IPs (must handle network changes)
- Works in: bare metal, QEMU VMs, and nixos-anywhere installs
- Zero configuration needed by user

## Tasks

### Task 1: Create runtime cache resolver service
**Type:** new-feature
**Files:** `modules/services/cache-resolver.nix`

**Action:**
Create a systemd service that runs at boot (before nix-daemon) to:
1. Attempt to resolve `waterbug.lan` via multiple methods:
   - DNS lookup (for networks with proper DNS)
   - mDNS/Avahi query (for .local fallback: `waterbug.local`)
   - Broadcast ping to common subnets (10.0.0.0/8, 192.168.0.0/16)
2. Test connectivity to resolved IP on port 9999
3. Write resolved IP to `/run/cache-resolver/waterbug-ip` (tmpfs)
4. Generate `/run/cache-resolver/nix.conf` with appropriate substituters:
   - If waterbug reachable: `http://<ip>:9999/system` first, then cache.nixos.org
   - If waterbug unreachable: just cache.nixos.org

**Service requirements:**
- Type: oneshot
- RemainAfterExit: true
- Before: nix-daemon.service
- Wants: network-online.target
- Timeout: 10 seconds (fast fail if waterbug absent)
- Restart: on-failure (network might come up late)

**Verify:**
```bash
# Service runs successfully
systemctl status cache-resolver.service

# Creates runtime files
ls -la /run/cache-resolver/

# waterbug reachable case
cat /run/cache-resolver/nix.conf | grep waterbug

# waterbug unreachable case
cat /run/cache-resolver/nix.conf | grep -v waterbug | grep cache.nixos.org
```

**Done when:**
- [ ] Service unit created with proper ordering
- [ ] Resolver script handles all 3 discovery methods
- [ ] Generated nix.conf includes correct substituters based on availability
- [ ] 10-second timeout prevents hanging on missing cache
- [ ] Service enabled by default when buildCache.enable = true

---

### Task 2: Integrate resolver with build-cache module
**Type:** refactor
**Files:** `modules/common/build-cache.nix`

**Action:**
Modify build-cache module to:
1. Remove hardcoded `serverUrl = "http://waterbug.lan:9999"`
2. Add option `dynamicResolution` (default: true)
3. When `dynamicResolution = true`:
   - Enable cache-resolver.service
   - Configure nix to include `/run/cache-resolver/nix.conf`
   - Keep `trusted-public-keys` in main config (doesn't change)
4. When `dynamicResolution = false`:
   - Use static `serverUrl` (for advanced users who want control)
5. Update `nix.settings.substituters` to:
   - Read from both static config AND runtime-generated config
   - Ensure cache.nixos.org is always included as fallback

**Implementation approach:**
```nix
nix.settings = {
  # Include runtime-generated substituters from cache-resolver
  include = lib.mkIf cfg.dynamicResolution [ "/run/cache-resolver/nix.conf" ];

  # Static substituters (fallback if resolver fails)
  substituters = lib.mkDefault [ "https://cache.nixos.org" ];

  # Trust keys (static)
  trusted-public-keys = [
    "system:oio0pk/Mlb/DR3s1b78tHHmOclp82OkQrYOTRlaqays="
    "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
  ];
};
```

**Verify:**
```bash
# Dynamic mode (default)
nix show-config | grep substituters
# Should show waterbug IP if reachable, cache.nixos.org always

# Static mode (advanced)
# In host config: myModules.services.buildCache.dynamicResolution = false;
nix show-config | grep substituters
# Should show hardcoded serverUrl
```

**Done when:**
- [ ] `dynamicResolution` option added
- [ ] cache-resolver.service enabled when dynamicResolution = true
- [ ] nix.settings.include points to runtime config
- [ ] Static fallback works when resolver fails
- [ ] Documentation updated with both modes

---

### Task 3: Fix VM test script for dynamic cache
**Type:** bug-fix
**Files:** `scripts/test-fresh-install.sh`

**Action:**
Update test-fresh-install.sh to work with dynamic resolution:

1. **Remove broken static /etc/hosts injection** (current approach)
2. **Add socat-based transparent proxy** for QEMU VMs:
   ```bash
   # On host: Start transparent proxy that forwards 10.0.2.2:9999 → waterbug:9999
   # This works because QEMU user-mode networking can always reach 10.0.2.2 (host)
   socat TCP-LISTEN:9999,bind=10.0.2.2,reuseaddr,fork \
         TCP:$(getent hosts waterbug.lan | awk '{print $1}'):9999 &
   PROXY_PID=$!
   trap "kill $PROXY_PID 2>/dev/null" EXIT
   ```

3. **In VM, configure cache-resolver to use 10.0.2.2**:
   ```bash
   # Via --extra-files, create /etc/cache-resolver/override
   # This tells cache-resolver: "use 10.0.2.2 instead of mDNS lookup"
   mkdir -p $EXTRA_FILES/etc/cache-resolver
   echo "10.0.2.2" > $EXTRA_FILES/etc/cache-resolver/waterbug-override
   ```

4. **Update cache-resolver.service** to check for override file first:
   ```bash
   if [ -f /etc/cache-resolver/waterbug-override ]; then
     WATERBUG_IP=$(cat /etc/cache-resolver/waterbug-override)
   else
     # Normal mDNS/DNS/broadcast resolution
   fi
   ```

**Why this works:**
- Host runs socat proxy that forwards VM's 10.0.2.2:9999 → actual waterbug IP
- Host dynamically resolves waterbug's current IP (handles IP changes)
- VM always uses 10.0.2.2 (stable QEMU gateway address)
- Graceful: if socat fails to resolve waterbug, VM falls back to cache.nixos.org

**Verify:**
```bash
# Run VM test
just vm-fresh griefling

# During installation, check cache access
ssh -p 22222 root@127.0.0.1 'cat /run/cache-resolver/nix.conf'
# Should show: substituters = http://10.0.2.2:9999/system ...

# Check cache hits
ssh -p 22222 root@127.0.0.1 'nix-store --query --deriver $(which bash)'
# Should show cache hits from local cache
```

**Done when:**
- [ ] socat proxy starts automatically in vm-fresh workflow
- [ ] Override file mechanism works in cache-resolver
- [ ] VM successfully pulls from cache via 10.0.2.2 proxy
- [ ] Graceful fallback if cache unavailable
- [ ] Script cleans up socat process on exit

---

## Verification

**Overall checks** (run these to confirm phase complete):

### Check 1: Bare metal with cache available
```bash
# On a host with buildCache.enable = true
systemctl status cache-resolver.service
# Should be: active (exited)

cat /run/cache-resolver/waterbug-ip
# Should contain waterbug's current IP

nix-build '<nixpkgs>' -A hello --option narinfo-cache-positive-ttl 0
# Should show: copying path ... from 'http://<waterbug-ip>:9999'
```

### Check 2: Bare metal with cache unavailable
```bash
# Disconnect from network with waterbug
# (or: sudo systemctl stop atticd on waterbug)

systemctl restart cache-resolver.service
systemctl status cache-resolver.service
# Should be: active (exited) - no error

cat /run/cache-resolver/nix.conf
# Should contain ONLY cache.nixos.org (no waterbug line)

nix-build '<nixpkgs>' -A hello
# Should work, using cache.nixos.org
```

### Check 3: VM installation with cache
```bash
# With waterbug running on network
just vm-fresh griefling

# Monitor installation logs for cache hits
# Should see: copying from http://10.0.2.2:9999/system
```

### Check 4: VM installation without cache
```bash
# Stop atticd on waterbug
sudo systemctl stop atticd

# Run vm-fresh
just vm-fresh griefling

# Should complete successfully using cache.nixos.org
# No DNS errors, no timeouts
```

---

## Success Criteria

Phase succeeds when:
- [ ] ISO installer works in all environments (bare metal, QEMU, nixos-anywhere)
- [ ] waterbug.lan cache is used when available (faster installs)
- [ ] Graceful fallback to cache.nixos.org when waterbug unavailable
- [ ] No hardcoded IPs (handles network changes dynamically)
- [ ] No user configuration needed (zero-touch automation)
- [ ] VM tests pass with cache: `just vm-fresh griefling` completes using local cache
- [ ] VM tests pass without cache: `just vm-fresh griefling` completes using upstream
- [ ] 10-second max delay when cache unavailable (no hanging)

---

## Checkpoints

**checkpoint:human-verify** - After Task 3, before marking phase complete

**What to verify:**
1. Run `just vm-fresh griefling` with cache available
   - Installation should be faster than typical
   - Check logs show cache hits from 10.0.2.2:9999

2. Stop atticd: `ssh waterbug sudo systemctl stop atticd`
   - Run `just vm-fresh griefling` again
   - Installation should complete successfully using cache.nixos.org
   - No errors about unreachable cache

3. Restart atticd: `ssh waterbug sudo systemctl start atticd`
   - Run `systemctl restart cache-resolver` on any managed host
   - Verify cache-resolver finds waterbug again

**Prompt:** "Verified all three scenarios work as expected?"
- Y → Phase complete, proceed to summary
- N → Investigate failures, iterate on tasks

---

## Output

**File:** `30-01-SUMMARY.md`

**Contents:**
```markdown
# Phase 30, Plan 1: Dynamic Cache Resolution - Summary

## Completed

**Objective:** ISO installer now gracefully resolves waterbug.lan cache with automatic fallback.

### Changes Made

**New files:**
- `modules/services/cache-resolver.nix` - Runtime cache discovery service
  - mDNS/DNS/broadcast resolution
  - Connectivity testing (10s timeout)
  - Dynamic nix.conf generation

**Modified files:**
- `modules/common/build-cache.nix`
  - Added `dynamicResolution` option (default: true)
  - Integrated cache-resolver.service
  - Runtime config inclusion via nix.settings.include

- `scripts/test-fresh-install.sh`
  - Added socat transparent proxy for QEMU VMs
  - Override mechanism for VM environments
  - Graceful cache fallback

**Git commits:**
- `abc123f` feat(cache): add runtime cache resolver service
- `def456g` feat(cache): integrate dynamic resolution into build-cache
- `ghi789h` fix(vm): add socat proxy for cache access in QEMU

### Deviations

[Document any deviations from plan using embedded rules 1-5]

### Verification Results

- [x] Bare metal with cache: ✅ Cache hits from waterbug
- [x] Bare metal without cache: ✅ Falls back to cache.nixos.org
- [x] VM with cache: ✅ Proxy works, cache hits from 10.0.2.2:9999
- [x] VM without cache: ✅ Graceful fallback, no errors

### Performance Impact

- Fresh install with cache: ~8min (vs ~25min without)
- Cache miss overhead: <10s (resolver timeout)
- Zero configuration needed ✅

## Issues Logged

[Any enhancements deferred to ISSUES.md per rule 5]

## Next Phase

Phase complete. No follow-up phases needed for cache resolution.
```

---

## Notes

**Design decisions:**

1. **Why socat proxy instead of hostfwd?**
   - QEMU hostfwd syntax is limited and broke with guestfwd attempts
   - socat is more flexible and handles dynamic upstream resolution
   - Transparent to the VM (just uses 10.0.2.2)

2. **Why runtime resolution instead of static config?**
   - IP addresses change (DHCP, network reconfigurations)
   - Cache may not always be available (laptop on-the-go)
   - Zero user intervention when network changes

3. **Why 10-second timeout?**
   - Fast enough to not annoy users when cache absent
   - Long enough for slow mDNS resolution
   - Prevents hanging boot processes

4. **Alternative approach considered:** Modify DNS with dnsmasq
   - More complex (requires dnsmasq setup)
   - Doesn't solve QEMU VM problem (user-mode networking)
   - Runtime resolver is simpler and more portable
