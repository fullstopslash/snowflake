---
phase: 02-role-system
plan: 03
type: execute
---

<objective>
Create the role definitions - device-type roles that bundle appropriate modules.

Purpose: Define what each device type (desktop, laptop, server, etc.) includes by default.
Output: /roles/ directory with all device roles that import appropriate modules.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/02-role-system/02-01-SUMMARY.md
@.planning/phases/02-role-system/02-02-SUMMARY.md
@modules/apps/default.nix
@modules/services/default.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create role infrastructure</name>
  <files>roles/default.nix, modules/common/roles.nix</files>
  <action>
Create the role option system:

1. **Create roles/ directory** at repo root

2. **Create modules/common/roles.nix** - role option definitions:
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  options.roles = {
    desktop = lib.mkEnableOption "Desktop workstation role";
    laptop = lib.mkEnableOption "Laptop role (desktop + power management)";
    server = lib.mkEnableOption "Headless server role";
    pi = lib.mkEnableOption "Raspberry Pi role";
    tablet = lib.mkEnableOption "Tablet role (touch-friendly)";
    darwin = lib.mkEnableOption "macOS/Darwin role";
    vm = lib.mkEnableOption "Virtual machine role";
  };

  # Assertions to prevent conflicting roles
  config.assertions = [
    {
      assertion = lib.count (x: x) [
        cfg.desktop cfg.laptop cfg.server cfg.pi cfg.tablet cfg.darwin cfg.vm
      ] <= 1;
      message = "Only one device role can be enabled at a time";
    }
  ];
}
```

3. **Create roles/default.nix** - imports all role files:
```nix
{ ... }: {
  imports = [
    ./desktop.nix
    ./laptop.nix
    ./server.nix
    ./pi.nix
    ./tablet.nix
    ./darwin.nix
    ./vm.nix
  ];
}
```

4. **Add roles.nix to modules/common/default.nix** imports so it's auto-loaded.
  </action>
  <verify>nix-instantiate --parse roles/default.nix && nix-instantiate --parse modules/common/roles.nix</verify>
  <done>Role infrastructure created with option definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create desktop and laptop roles</name>
  <files>roles/desktop.nix, roles/laptop.nix</files>
  <action>
Create the primary workstation roles:

**roles/desktop.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.desktop {
    # Desktop gets full GUI experience
    imports = [
      # Desktop environment
      ../modules/services/desktop
      ../modules/services/audio

      # Applications
      ../modules/apps/cli
      ../modules/apps/fonts
      ../modules/apps/media
      ../modules/apps/gaming
      ../modules/apps/theming
      ../modules/apps/development

      # Services
      ../modules/services/networking
      ../modules/services/development
      ../modules/services/security
      ../modules/services/ai
    ];

    # Desktop-specific defaults
    services.xserver.enable = lib.mkDefault true;
    hardware.graphics.enable = lib.mkDefault true;
  };
}
```

**roles/laptop.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.laptop {
    # Laptop = desktop + power management + wifi
    imports = [
      ./desktop.nix  # Inherit desktop role
    ];

    # Laptop-specific additions
    roles.desktop = lib.mkForce false;  # Don't double-enable

    # Power management
    services.thermald.enable = lib.mkDefault true;
    services.power-profiles-daemon.enable = lib.mkDefault true;
    powerManagement.enable = lib.mkDefault true;

    # Wifi by default
    networking.wireless.enable = lib.mkDefault false;  # Use networkmanager instead
    networking.networkmanager.wifi.powersave = lib.mkDefault true;

    # Laptop hardware
    services.libinput.enable = lib.mkDefault true;
    hardware.bluetooth.enable = lib.mkDefault true;
  };
}
```

Note: The import pattern above may need adjustment - roles importing modules directly using lib.mkIf may not work. Alternative is to use the module system properly with config = lib.mkIf. Test and adjust as needed.
  </action>
  <verify>nix-instantiate --parse roles/desktop.nix && nix-instantiate --parse roles/laptop.nix</verify>
  <done>Desktop and laptop roles created</done>
</task>

<task type="auto">
  <name>Task 3: Create server, pi, tablet, darwin, vm roles</name>
  <files>roles/server.nix, roles/pi.nix, roles/tablet.nix, roles/darwin.nix, roles/vm.nix</files>
  <action>
Create remaining device roles:

**roles/server.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.server {
    # Headless server - no GUI
    imports = [
      ../modules/apps/cli
      ../modules/services/networking
      ../modules/services/security
    ];

    # Server defaults
    services.openssh.enable = lib.mkDefault true;
    networking.firewall.enable = lib.mkDefault true;

    # No GUI
    services.xserver.enable = lib.mkDefault false;
    sound.enable = lib.mkDefault false;
  };
}
```

**roles/pi.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.pi {
    # Raspberry Pi - aarch64, headless by default
    imports = [
      ../modules/apps/cli
      ../modules/services/networking
    ];

    # Pi-specific
    boot.loader.grub.enable = lib.mkDefault false;
    boot.loader.generic-extlinux-compatible.enable = lib.mkDefault true;

    # Minimal footprint
    documentation.enable = lib.mkDefault false;
    services.openssh.enable = lib.mkDefault true;
  };
}
```

**roles/tablet.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.tablet {
    # Tablet - touch-friendly desktop
    imports = [
      ../modules/services/desktop
      ../modules/services/audio
      ../modules/apps/cli
      ../modules/apps/fonts
      ../modules/apps/media
    ];

    # Touch input
    services.libinput.enable = lib.mkDefault true;

    # On-screen keyboard
    # programs.squeekboard.enable = lib.mkDefault true;  # if available

    # Power management
    powerManagement.enable = lib.mkDefault true;
  };
}
```

**roles/darwin.nix:**
```nix
{ config, lib, pkgs, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.darwin {
    # macOS - placeholder for T2 MacBook
    # Note: Darwin uses nix-darwin, not NixOS modules

    # For now, just document intended behavior
    # Actual implementation requires nix-darwin integration

    warnings = [
      "Darwin role is a placeholder - requires nix-darwin integration"
    ];
  };
}
```

**roles/vm.nix:**
```nix
{ config, lib, ... }:
let
  cfg = config.roles;
in {
  config = lib.mkIf cfg.vm {
    # Virtual machine - minimal for testing
    imports = [
      ../modules/apps/cli
    ];

    # VM-specific
    services.qemuGuest.enable = lib.mkDefault true;
    services.spice-vdagentd.enable = lib.mkDefault true;

    # Minimal
    documentation.enable = lib.mkDefault false;
    boot.loader.timeout = lib.mkDefault 1;
  };
}
```
  </action>
  <verify>for f in roles/*.nix; do nix-instantiate --parse "$f" || echo "FAILED: $f"; done</verify>
  <done>All 7 device roles created (desktop, laptop, server, pi, tablet, darwin, vm)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] roles/ directory exists with all 7 role files + default.nix
- [ ] modules/common/roles.nix defines role options
- [ ] All role files parse without syntax errors
- [ ] Role options are mutually exclusive (assertion exists)
</verification>

<success_criteria>
- 7 device roles defined (desktop, laptop, server, pi, tablet, darwin, vm)
- Each role imports appropriate modules
- Role option system (roles.X.enable) in place
- Roles set sensible defaults with lib.mkDefault (overridable)
</success_criteria>

<output>
After completion, create `.planning/phases/02-role-system/02-03-SUMMARY.md`
</output>
