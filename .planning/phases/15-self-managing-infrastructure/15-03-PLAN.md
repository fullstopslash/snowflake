---
phase: 15-self-managing-infrastructure
plan: 15-03
title: Decentralized GitOps Safety - Chezmoi & Config Repo Management
depends_on:
  - Phase 6 (Auto-upgrade module with git pull + rebuild)
  - Phase 4 (SOPS secrets with SSH keys)
  - Phase 15-01 (Golden boot entry and rollback)
status: split_into_subplans
note: "This plan has been split into three focused sub-plans for perfect implementation"
subplans:
  - 15-03a: Chezmoi Sync Module with Jujutsu
  - 15-03b: Auto-Upgrade Extensions for Safety
  - 15-03c: Secret Migration and Comprehensive Testing
---

# NOTE: This Plan Has Been Split

This comprehensive plan has been split into three focused sub-plans to ensure perfect implementation:

1. **15-03a-PLAN.md** - Chezmoi Sync Module with Jujutsu
   - Core jj-based synchronization module
   - Sync scripts and manual commands
   - systemd services and state tracking
   - Role integration

2. **15-03b-PLAN.md** - Auto-Upgrade Extensions for Safety
   - Extend auto-upgrade with preUpdateValidation
   - Add preUpdateHooks for extensibility
   - Build validation (nh os build before switch)
   - Optional config commit logic

3. **15-03c-PLAN.md** - Secret Migration and Comprehensive Testing
   - Migrate secrets from chezmoi to SOPS
   - Initialize chezmoi with jj on all hosts
   - Comprehensive end-to-end testing
   - Documentation creation

**Implement these sub-plans in order: 15-03a → 15-03b → 15-03c**

The content below represents the original comprehensive plan and serves as reference documentation.

---

# Plan 15-03: Decentralized GitOps Safety - Chezmoi & Config Repo Management

## Objective

Enable safe decentralized GitOps where multiple hosts can independently commit changes to both the NixOS config repo and the chezmoi dotfiles repo without conflicts, ensuring all hosts stay synchronized and changes never clobber each other.

**Critical requirement**: The chezmoi synchronization system MUST be bulletproof. Multiple hosts modifying dotfiles simultaneously must not result in lost changes or conflicts that break the system.

**Key Innovation**: Use **Jujutsu (jj)** for chezmoi repository management instead of git. jj's conflict-free merge model makes multi-host synchronization trivial - conflicts become parallel commits instead of blocking failures. No manual conflict resolution needed, no lost work, fully automated.

## Success Criteria

### Chezmoi Repository Management
- [ ] Chezmoi repo automatically syncs before any OS update
- [ ] `chezmoi re-add` captures all local dotfile changes
- [ ] Commits include hostname and timestamp for traceability
- [ ] Git pull handles merge conflicts gracefully (auto-merge or fail-safe)
- [ ] Push failures (no network) don't break the update workflow
- [ ] Multiple hosts can commit simultaneously without data loss
- [ ] All hosts eventually converge to latest state
- [ ] Chezmoi templates migrated away from secrets (use SOPS instead)

### NixOS Config Repository Management
- [ ] Pre-update validation builds config before switching
- [ ] Build failures prevent deployment (no broken boots)
- [ ] Hosts can optionally commit config changes (with validation)
- [ ] Integration with golden generation rollback system
- [ ] Clear separation: chezmoi for dotfiles, SOPS for secrets

### Safety & Reliability
- [ ] Network failures handled gracefully (offline mode)
- [ ] Merge conflicts don't break automation
- [ ] State recovery tools for manual intervention
- [ ] Comprehensive logging for debugging
- [ ] Tested in griefling VM with simulated conflicts

## Context

**Current State**:
- Auto-upgrade module pulls nix-config repo and rebuilds daily (Phase 6)
- SSH keys deployed via SOPS for git push access (Phase 4)
- Golden boot entry system protects against bad deployments (Phase 15-01)
- Chezmoi manages dotfiles but has NO automation for commits/sync

**The Problem**:
When multiple hosts modify dotfiles and the NixOS config:
1. **Dotfile drift**: Local changes in ~/.local/share/chezmoi not committed
2. **Clobber risk**: Host A commits dotfiles, Host B commits different changes → conflict or data loss
3. **Lost work**: OS update wipes uncommitted chezmoi changes
4. **Secret leakage**: Chezmoi templates contain secrets (should use SOPS)

**The Solution Architecture**:
```
┌─────────────────────────────────────────────────────────┐
│                   Before OS Update                       │
│  1. Sync chezmoi repo (pull + re-add + commit + push)  │
│  2. Sync nix-config repo (pull)                         │
│  3. Build new config (validation)                        │
│  4. If build succeeds → deploy                           │
│  5. If deploy fails → rollback to golden                 │
└─────────────────────────────────────────────────────────┘

       Host A                  Host B                  Host C
          │                      │                       │
          │ chezmoi sync         │ chezmoi sync          │ chezmoi sync
          ▼                      ▼                       ▼
    ┌─────────────────────────────────────────────────────┐
    │            Chezmoi Dotfiles Repo (GitHub)           │
    │  - Host-specific files: .chezmoidata.<hostname>.yaml│
    │  - Shared files: merge on pull                      │
    │  - Timestamp commits: no race conditions            │
    └─────────────────────────────────────────────────────┘

       Host A                  Host B                  Host C
          │                      │                       │
          │ config pull          │ config pull           │ config pull
          ▼                      ▼                       ▼
    ┌─────────────────────────────────────────────────────┐
    │          NixOS Config Repo (Current Repo)           │
    │  - Hosts pull and rebuild (Phase 6)                 │
    │  - Optional: hosts can push changes (with build)    │
    └─────────────────────────────────────────────────────┘
```

## Implementation Strategy

### Part 1: Chezmoi Repository Management (Critical)

**Philosophy**: Chezmoi is a **distributed append-only log** where each host contributes its local state. Conflicts are resolved by **latest timestamp wins** or **host-specific files**.

**Key Insight**: Chezmoi's `re-add` command captures current dotfile state. By running this before every OS update, we ensure local changes are never lost.

**Conflict Resolution Strategy**:
1. **Host-specific files**: `.chezmoidata.<hostname>.yaml` for host-specific config
2. **Shared files**: Automatically merge (git merge or git rebase)
3. **Conflict files**: Auto-merge with markers, log for manual review
4. **Push failures**: Queue for retry, don't block OS update

**Implementation**:
- Create `modules/services/dotfiles/chezmoi-sync.nix` module
- Pre-update systemd service: `chezmoi-pre-update.service`
- Post-update systemd service: `chezmoi-post-update.service` (optional)
- Manual commands: `chezmoi-sync`, `chezmoi-status`, `chezmoi-resolve-conflicts`

### Part 2: Pre-Update Validation

**Philosophy**: Never deploy a config that doesn't build. Validation prevents broken boots.

**Implementation**:
- Extend `modules/services/system/auto-upgrade.nix` (Phase 6)
- Add `preUpdateValidation` option
- Run `nh os build` before `nh os switch`
- If build fails → log error, don't deploy, notify user
- If build succeeds → proceed with deployment

### Part 3: Optional Config Repo Commits

**Philosophy**: Hosts CAN commit config changes, but it's optional. Desktop hosts might commit manual tweaks, servers just pull.

**Implementation**:
- Add `hostCanCommitConfig` option to auto-upgrade module
- Pre-commit hook validates build before push
- Hostname + timestamp in commit messages
- Push failures are logged but don't break workflow

## Detailed Design

### Why Jujutsu (jj) Instead of Git

**Critical Advantage for Multi-Host Sync**:
- **Automatic conflict resolution**: jj creates new commits for both sides of conflicts, no manual intervention needed
- **No lost work**: All changes preserved as separate commits, can be reconciled later
- **Simpler mental model**: jj co-locate (working copy tracks @ bookmark automatically)
- **Better merge handling**: `jj git fetch` + `jj rebase` handles concurrent edits elegantly
- **Offline resilience**: jj local operations continue even without network

**Architecture**:
- Chezmoi repo is a **jj co-located repository** (jj + git backend)
- Each host has `~/.local/share/chezmoi` as jj working copy
- Automatic sync uses jj commands, git backend for GitHub compatibility
- Conflicts become parallel commits, not blocked merges

### Module: `modules/services/dotfiles/chezmoi-sync.nix`

**Options**:
```nix
myModules.services.dotfiles.chezmoiSync = {
  enable = lib.mkEnableOption "automatic chezmoi repository synchronization";

  repoUrl = lib.mkOption {
    type = lib.types.str;
    example = "git@github.com:user/dotfiles.git";
    description = "Git URL for chezmoi dotfiles repository (jj uses git backend)";
  };

  syncBeforeUpdate = lib.mkOption {
    type = lib.types.bool;
    default = true;
    description = "Automatically sync chezmoi before OS updates";
  };

  autoCommit = lib.mkOption {
    type = lib.types.bool;
    default = true;
    description = "Automatically commit local changes with timestamp";
  };

  autoPush = lib.mkOption {
    type = lib.types.bool;
    default = true;
    description = "Automatically push commits to remote (fails gracefully if no network)";
  };

  conflictHandling = lib.mkOption {
    type = lib.types.enum [ "auto-reconcile" "manual" ];
    default = "auto-reconcile";
    description = ''
      How to handle conflicts:
      - auto-reconcile: Use jj's automatic conflict resolution (recommended)
      - manual: Log conflicts for user review, don't auto-reconcile
    '';
  };
};
```

**Services**:

1. **`chezmoi-pre-update.service`** - Runs before auto-upgrade
   - Order: `Before = [ "auto-upgrade.service" ]` (if auto-upgrade enabled)
   - Steps (using jj commands):
     1. `cd ~/.local/share/chezmoi`
     2. `jj git fetch` (fetch from git remote)
     3. `jj rebase -d @- -s @` (rebase working copy on fetched changes)
        - jj automatically handles conflicts by creating parallel commits
        - No manual conflict resolution needed
     4. `chezmoi re-add` (captures all current dotfiles)
     5. `jj describe -m "chore($(hostname)): sync dotfiles - $(date -Iseconds)"` (update working copy commit message)
     6. `jj git push` (push to git remote via jj)
        - Fails gracefully if no network
        - jj tracks what's pushed, can resume later
   - Logging: Full transcript to systemd journal
   - State file: `/var/lib/chezmoi-sync/last-sync-status`

2. **`chezmoi-conflict-checker.service`** (optional timer)
   - Runs daily to check for conflicts in jj log
   - Notifies user if conflicts exist (for manual reconciliation if desired)
   - Command: `jj log --conflicts` to find conflict commits

**Scripts**:

```bash
# chezmoi-sync (manual command)
#!/usr/bin/env bash
# Performs full chezmoi sync using jj: fetch, rebase, re-add, describe, push

# chezmoi-status (manual command)
#!/usr/bin/env bash
# Shows jj log, working copy status, conflicts

# chezmoi-show-conflicts (manual command)
#!/usr/bin/env bash
# Lists any conflict commits in jj log

# chezmoi-resolve-conflicts (manual command)
#!/usr/bin/env bash
# Interactive tool to manually reconcile conflicts if auto-reconcile is disabled
```

### Module: Extend `modules/services/system/auto-upgrade.nix`

**New Options**:
```nix
myModules.services.system.autoUpgrade = {
  # Existing options...

  preUpdateValidation = lib.mkOption {
    type = lib.types.bool;
    default = true;
    description = "Build config before deploying to catch errors early";
  };

  hostCanCommitConfig = lib.mkOption {
    type = lib.types.bool;
    default = false;
    description = "Allow this host to commit and push nix-config changes";
  };

  preUpdateHooks = lib.mkOption {
    type = lib.types.listOf lib.types.str;
    default = [];
    description = "Services to run before update (e.g., chezmoi-pre-update)";
  };
};
```

**Updated auto-upgrade service**:
```nix
systemd.services.auto-upgrade = {
  # ... existing config

  # Add ordering for pre-update hooks
  after = cfg.preUpdateHooks;
  wants = cfg.preUpdateHooks;

  script = ''
    # Pull latest config
    git -C ${cfg.configPath} pull origin ${cfg.branch}

    # Validate build (if enabled)
    ${lib.optionalString cfg.preUpdateValidation ''
      echo "Validating build before deployment..."
      if ! nh os build -u; then
        echo "Build failed! Aborting deployment."
        logger -t auto-upgrade "Build validation failed, aborting update"
        exit 1
      fi
      echo "Build validation succeeded"
    ''}

    # Deploy
    nh os switch -u

    # Optional: Commit config changes (if host is allowed)
    ${lib.optionalString cfg.hostCanCommitConfig ''
      # Check for uncommitted changes
      if ! git -C ${cfg.configPath} diff --quiet; then
        git -C ${cfg.configPath} add .
        git -C ${cfg.configPath} commit -m "chore($(hostname)): auto-update $(date -Iseconds)"
        git -C ${cfg.configPath} push origin ${cfg.branch} || echo "Push failed (no network?)"
      fi
    ''}
  '';
};
```

### Chezmoi Sync Script (Core Logic with jj)

```bash
#!/usr/bin/env bash
set -euo pipefail

CHEZMOI_DIR="$HOME/.local/share/chezmoi"
STATE_DIR="/var/lib/chezmoi-sync"
STATE_FILE="$STATE_DIR/last-sync-status"
HOSTNAME=$(hostname)

mkdir -p "$STATE_DIR"

log() {
  echo "[chezmoi-sync] $*"
  logger -t chezmoi-sync "$*"
}

cd "$CHEZMOI_DIR"

# Ensure jj is initialized (co-located with git)
if [ ! -d .jj ]; then
  log "Initializing jj co-located repo..."
  jj git init --colocate
fi

# Step 1: Fetch remote changes via jj
log "Fetching remote changes..."
if ! jj git fetch; then
  log "Warning: Could not fetch (no network?)"
  echo "fetch-failed" > "$STATE_FILE"
  exit 0  # Don't fail, just skip sync
fi

# Step 2: Rebase working copy on latest remote
log "Rebasing working copy on remote changes..."
# jj rebase automatically handles conflicts by creating separate commits
# No manual intervention needed - conflicts preserved as parallel history
jj rebase -d @- -s @

# Check if conflicts exist (for logging)
if jj log --conflicts -r @ &>/dev/null; then
  CONFLICTS=$(jj log --conflicts -r @ --no-graph -T 'change_id' | wc -l)
  if [ "$CONFLICTS" -gt 0 ]; then
    log "Note: $CONFLICTS conflict(s) detected - preserved as separate commits"
    echo "conflicts-preserved" > "$STATE_FILE"
  fi
fi

# Step 3: Capture current dotfiles state with chezmoi re-add
log "Capturing current dotfiles with chezmoi re-add..."
chezmoi re-add

# Step 4: Update working copy description (commit message)
log "Updating commit description..."
jj describe -m "chore($HOSTNAME): sync dotfiles - $(date -Iseconds)"

# Step 5: Push to git remote
log "Pushing to git remote..."
if jj git push; then
  log "Successfully pushed changes"
  echo "success" > "$STATE_FILE"
else
  log "Warning: Could not push (no network?)"
  echo "push-failed" > "$STATE_FILE"
  # Don't fail - changes are committed locally
  # jj will push on next successful sync
  exit 0
fi

log "Chezmoi sync complete"
```

### Why This is Better Than Git

**No conflict handling function needed!** jj does it automatically:

1. **Automatic conflict resolution**: jj creates new commits for both sides, no merge failure
2. **No lost work**: All changes preserved in history as separate commits
3. **Deferred reconciliation**: Conflicts can be resolved later at user's convenience
4. **Simpler code**: No complex merge/rebase/conflict logic needed
5. **Offline-first**: jj local operations work without network
6. **Resume-friendly**: Failed pushes are tracked, resume automatically next sync

**Example conflict scenario with jj**:
```
Host A: Modifies .bashrc → commits → pushes
Host B: Also modifies .bashrc → commits locally
Host B: Fetches (sees Host A's change)
Host B: Rebases → jj creates TWO commits (one for each change)
Host B: Pushes → both changes preserved, user can reconcile later
```

Compare to git:
```
Host A: Modifies .bashrc → commits → pushes
Host B: Also modifies .bashrc → commits locally
Host B: git pull → CONFLICT! Sync blocks
Host B: Must manually resolve before proceeding
```

## Migration: Secrets Out of Chezmoi

**Current Problem**: Chezmoi templates contain secrets that should be in SOPS.

**Missing template variables** (from context):
- `acoustid_api`
- `email_personal`
- `desktop`
- `name`

**Migration Strategy**:

1. **Audit chezmoi templates** for secret usage:
   ```bash
   grep -r "{{" ~/.local/share/chezmoi/
   ```

2. **Move secrets to SOPS**:
   - Create `secrets/dotfiles.yaml` for dotfile-related secrets
   - Reference SOPS-decrypted files in chezmoi templates
   - Use environment variables or file includes

3. **Example transformation**:
   ```diff
   # Before (in chezmoi template)
   - api_key = "{{ .acoustid_api }}"

   # After (reference SOPS)
   - api_key = "{{ env "ACOUSTID_API" }}"
   ```

   Or use file includes:
   ```bash
   # In chezmoi template
   {{ include "/run/secrets/acoustid_api" }}
   ```

4. **Update chezmoi data files**:
   - Move non-secret config to `.chezmoidata.yaml`
   - Keep host-specific config in `.chezmoidata.<hostname>.yaml`

**Task**: Create migration checklist as part of implementation

## Implementation Steps

### Step 1: Create Chezmoi Sync Module

**File**: `modules/services/dotfiles/chezmoi-sync.nix`

- Implement options (repoUrl, syncBeforeUpdate, mergeStrategy, conflictHandling)
- Create sync script with all logic (pull, re-add, commit, push)
- Create conflict handler with all three strategies
- Create manual commands (chezmoi-sync, chezmoi-status, chezmoi-resolve-conflicts)
- Create systemd services (chezmoi-pre-update, chezmoi-conflict-resolver)
- Add state directory `/var/lib/chezmoi-sync/`

### Step 2: Extend Auto-Upgrade Module

**File**: `modules/services/system/auto-upgrade.nix`

- Add `preUpdateValidation` option
- Add `hostCanCommitConfig` option
- Add `preUpdateHooks` option
- Implement build validation (nh os build before nh os switch)
- Implement optional config commit logic
- Update service ordering to run hooks first

### Step 3: Ensure jj is Available

**Files**: Add jujutsu to appropriate modules

Since jj is used for chezmoi sync, ensure it's installed where chezmoi is used:

```nix
# In modules/services/dotfiles/chezmoi-sync.nix
config = lib.mkIf cfg.enable {
  # Ensure jj is available for sync operations
  environment.systemPackages = with pkgs; [
    jujutsu  # Required for conflict-free multi-host sync
  ];

  # ... rest of config
};
```

### Step 4: Enable Chezmoi Sync in Roles

**Files**: `roles/form-desktop.nix`, `roles/form-laptop.nix`, `roles/form-server.nix`

Desktop/Laptop (enable with auto-reconcile):
```nix
myModules.services.dotfiles.chezmoiSync = {
  enable = lib.mkDefault true;
  repoUrl = lib.mkDefault "git@github.com:user/dotfiles.git";  # User will override
  syncBeforeUpdate = lib.mkDefault true;
  conflictHandling = lib.mkDefault "auto-reconcile";  # jj handles conflicts automatically
};

myModules.services.system.autoUpgrade.preUpdateHooks = lib.mkDefault [
  "chezmoi-pre-update.service"
];
```

Server/Pi (same settings - jj makes it safe):
```nix
myModules.services.dotfiles.chezmoiSync = {
  enable = lib.mkDefault true;
  repoUrl = lib.mkDefault "git@github.com:user/dotfiles.git";
  syncBeforeUpdate = lib.mkDefault true;
  conflictHandling = lib.mkDefault "auto-reconcile";  # Safe even for servers
};
```

**Note**: With jj, we can use the same conflict handling everywhere. No need for conservative "fail-safe" mode since jj never blocks on conflicts.

### Step 4: Migrate Chezmoi Secrets to SOPS

**Tasks**:
1. Audit all chezmoi templates for secret usage
2. Create `secrets/dotfiles.yaml` with identified secrets
3. Update chezmoi templates to reference SOPS instead
4. Test on malphas (desktop) first
5. Document migration process for other hosts

### Step 5: Initialize Chezmoi with jj

**Prerequisites**: User must have chezmoi dotfiles repo

**Manual initialization steps** (one-time per host):
```bash
# 1. Initialize chezmoi (if not already done)
chezmoi init git@github.com:user/dotfiles.git

# 2. Convert chezmoi repo to jj co-located
cd ~/.local/share/chezmoi
jj git init --colocate

# 3. Verify jj working
jj log
jj status

# 4. First sync
jj git fetch
jj rebase -d @- -s @
chezmoi re-add
jj describe -m "chore($(hostname)): initial jj setup"
jj git push
```

**Or add initialization to chezmoi-sync module**:
```nix
# Auto-initialize on first run
systemd.services.chezmoi-init = {
  description = "Initialize chezmoi with jj";
  wantedBy = [ "multi-user.target" ];
  after = [ "network-online.target" ];

  # Only run if chezmoi not initialized
  unitConfig = {
    ConditionPathExists = "!%h/.local/share/chezmoi";
  };

  script = ''
    # Clone chezmoi repo
    ${pkgs.chezmoi}/bin/chezmoi init ${cfg.repoUrl}

    # Convert to jj co-located
    cd ~/.local/share/chezmoi
    ${pkgs.jujutsu}/bin/jj git init --colocate

    echo "Chezmoi initialized with jj"
  '';

  serviceConfig = {
    Type = "oneshot";
    User = "%u";  # Run as user
  };
};
```

### Step 6: Test in Griefling VM

**Test Scenarios**:

1. **Normal sync**: Modify dotfiles, trigger OS update, verify chezmoi syncs
2. **Conflict simulation with jj**: Modify same file on griefling and malphas simultaneously, verify both changes preserved
3. **Network failure**: Disable network, trigger update, verify graceful degradation
4. **Build failure**: Introduce config error, verify validation catches it
5. **jj conflict reconciliation**: Create conflict, verify jj preserves both versions, manually reconcile

**Test Scripts**:

```bash
# Test 1: Normal sync
# On griefling VM

# 1. Modify dotfile
echo "# Griefling test change $(date)" >> ~/.bashrc

# 2. Trigger OS update
sudo systemctl start auto-upgrade.service

# 3. Verify chezmoi sync ran
journalctl -u chezmoi-pre-update.service

# 4. Check jj log for commit
cd ~/.local/share/chezmoi
jj log -r @
jj status

# 5. Verify state file
cat /var/lib/chezmoi-sync/last-sync-status

# Test 2: Conflict simulation
# On malphas (desktop)
cd ~/.local/share/chezmoi
echo "# Malphas change" >> dot_bashrc
jj describe -m "test: malphas bashrc change"
jj git push

# On griefling (at same time)
cd ~/.local/share/chezmoi
echo "# Griefling change" >> dot_bashrc
# Trigger sync (will fetch malphas's change)
sudo systemctl start chezmoi-pre-update.service

# Verify both changes preserved
jj log --limit 5
# Should see TWO separate commits for bashrc changes

# Test 3: Network failure
# On griefling
sudo systemctl stop NetworkManager
sudo systemctl start auto-upgrade.service
# Should gracefully skip fetch/push, not fail
journalctl -u chezmoi-pre-update.service | grep "Warning.*network"

# Test 4: Conflict resolution (manual reconciliation)
cd ~/.local/share/chezmoi
jj log --conflicts
# If conflicts exist, use jj to reconcile:
jj resolve  # Interactive conflict resolution
```

**Expected outcomes**:
- ✅ All syncs succeed even with concurrent changes
- ✅ No changes lost, even with conflicts
- ✅ Network failures don't break workflow
- ✅ jj log shows clear history of all changes
- ✅ Conflicts preserved for later reconciliation

### Step 6: Documentation

**Create**:
- `docs/chezmoi-gitops.md` - Architecture and workflow
- `docs/chezmoi-migration.md` - Secret migration guide
- `docs/conflict-resolution.md` - How to handle conflicts
- Update README with chezmoi sync info

**Document**:
- How multi-host sync works
- Conflict resolution strategies
- Manual commands for debugging
- State file meanings
- Recovery procedures

## Rollback Plan

If chezmoi sync causes issues:

1. **Disable sync**: Set `myModules.services.dotfiles.chezmoiSync.enable = false;`
2. **Remove pre-update hook**: Set `preUpdateHooks = [];` in auto-upgrade
3. **Manual sync**: Use `chezmoi-sync` command manually when needed
4. **Conflict recovery**:
   ```bash
   cd ~/.local/share/chezmoi
   git merge --abort  # or git rebase --abort
   git reset --hard origin/main
   chezmoi apply
   ```

## Security Considerations

1. **SSH key protection**: Keys deployed via SOPS (already done in Phase 4)
2. **Repo access control**: Only authorized hosts have push access
3. **Secrets in commits**: Never commit secrets to chezmoi repo (use SOPS)
4. **Conflict markers**: May leak sensitive filenames (acceptable for dotfiles)
5. **State files**: Store in `/var/lib/` with root-only access

## Open Questions

1. **Chezmoi repo location**: User needs to provide their chezmoi repo URL - prompt for this?
2. **Initial chezmoi setup**: If chezmoi not initialized, auto-init or fail gracefully?
3. **Host-specific vs shared**: Which dotfiles should be host-specific vs shared?
4. **Conflict notification**: How to alert user about auto-merged conflicts?
5. **Retry logic**: Should failed pushes retry automatically or wait for next cycle?

**Decision gate**: Present these questions to user before implementation.

## Dependencies

- Phase 6: Auto-upgrade module (exists)
- Phase 4: SOPS with SSH keys (exists)
- Phase 15-01: Golden boot entry (completed in current session)
- Chezmoi installed and initialized (user prerequisite)
- Git repo for dotfiles (user must provide)

## Estimated Scope

This is a LARGE plan due to critical safety requirements. Split into sub-plans:

**Recommended approach**:
- **15-03a**: Chezmoi sync module only (core functionality)
- **15-03b**: Auto-upgrade extensions (validation, hooks)
- **15-03c**: Secret migration and testing

Or implement as single plan if context permits (currently at ~60% context usage).

**User decision needed**: Proceed as single plan or split into 3 sub-plans?
