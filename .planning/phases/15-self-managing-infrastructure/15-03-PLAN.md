# Plan 15-03: Decentralized GitOps Safety

## Goal
Enable hosts to safely commit and push changes, with systemd watchdog for boot failure detection and automatic rollback to golden generation.

## Context
From ROADMAP Phase 15:
- Vision: Any host can commit changes to repo (true decentralized management)
- All hosts pull changes and validate before rebuilding
- If boot fails after update â†’ automatic rollback to golden generation
- Depends on: Plan 15-01 (golden generation), Plan 15-02 (validation)

## Current State
- âœ… Hosts can git pull (auto-upgrade module)
- âœ… SSH keys deployed via SOPS for git access
- â³ No commit automation
- â³ No boot failure detection
- â³ No automatic rollback

## Implementation Steps

### 1. Boot Failure Detection with Systemd
**File**: `modules/system/boot/golden-generation.nix` (extend from 15-01)

Add boot validation service:
```nix
# Boot success validation
systemd.services.golden-boot-validation = {
  description = "Validate successful boot";
  wantedBy = [ "multi-user.target" ];
  after = [ "network.target" ];

  serviceConfig = {
    Type = "oneshot";
    RemainAfterExit = true;
    ExecStart = pkgs.writeScript "validate-boot" ''
      #!/usr/bin/env bash
      set -euo pipefail

      state_file="${stateDir}/boot-failures"
      pending_file="${stateDir}/boot-pending"

      # If this is a pending boot, validate it succeeded
      if [ -f "$pending_file" ]; then
        # Boot succeeded! Reset failure counter
        echo "0" > "$state_file"
        rm "$pending_file"
        echo "Boot validation: SUCCESS"
      fi
    '';
  };
};

# Pre-switch hook: mark boot as pending
systemd.services.golden-pre-switch = {
  description = "Mark new configuration as pending validation";
  requiredBy = [ "nixos-rebuild.service" ];
  before = [ "nixos-rebuild.service" ];

  serviceConfig = {
    Type = "oneshot";
    ExecStart = pkgs.writeScript "mark-pending" ''
      #!/usr/bin/env bash
      mkdir -p ${stateDir}
      touch ${stateDir}/boot-pending
      echo "Marked new config as pending validation"
    '';
  };
};

# Early boot check: detect failed boots
systemd.services.golden-boot-check = {
  description = "Check for boot failures and rollback if needed";
  wantedBy = [ "sysinit.target" ];
  before = [ "sysinit.target" ];

  serviceConfig = {
    Type = "oneshot";
    ExecStart = pkgs.writeScript "check-boot-failures" ''
      #!/usr/bin/env bash
      set -euo pipefail

      state_file="${stateDir}/boot-failures"
      golden_file="${stateDir}/golden-generation-number"
      max_failures=2

      # Initialize if needed
      [ -f "$state_file" ] || echo "0" > "$state_file"

      failures=$(cat "$state_file")

      # If previous boot was pending but we're here again, it failed
      if [ -f "${stateDir}/boot-pending" ]; then
        failures=$((failures + 1))
        echo "$failures" > "$state_file"
        echo "Boot failure detected (count: $failures)"
      fi

      # Too many failures? Rollback to golden
      if [ "$failures" -ge "$max_failures" ]; then
        if [ -f "$golden_file" ]; then
          golden=$(cat "$golden_file")
          echo "Too many failures ($failures), rolling back to generation $golden"

          # Switch to golden generation
          /nix/var/nix/profiles/system-$golden/bin/switch-to-configuration boot

          # Reset counter
          echo "0" > "$state_file"
          rm -f "${stateDir}/boot-pending"

          # Reboot to golden
          reboot
        fi
      fi
    '';
  };
};
```

### 2. Host Commit Automation
**File**: `modules/system/git-management.nix` (new module)

```nix
{ config, lib, pkgs, ... }:
let
  cfg = config.myModules.system.gitManagement;

  commitScript = pkgs.writeShellScript "host-commit" ''
    #!/usr/bin/env bash
    set -euo pipefail

    cd ${cfg.repoPath}

    # Check if there are changes
    if ! git diff --quiet || ! git diff --cached --quiet; then
      # Create automated commit
      git add -A
      git commit -m "Auto-commit from ${config.networking.hostName}

    Changes detected on $(date -Is)
    Host: ${config.networking.hostName}

    ðŸ¤– Automated commit
    "

      # Push if enabled
      if ${lib.boolToString cfg.autoPush}; then
        git push origin ${cfg.branch}
      fi
    fi
  '';

in
{
  options.myModules.system.gitManagement = {
    enable = lib.mkEnableOption "Git management for host";

    repoPath = lib.mkOption {
      type = lib.types.str;
      default = "/home/${config.hostSpec.primaryUsername}/nix-config";
      description = "Path to git repository";
    };

    autoPush = lib.mkOption {
      type = lib.types.bool;
      default = false;
      description = "Automatically push commits";
    };

    branch = lib.mkOption {
      type = lib.types.str;
      default = "dev";
      description = "Branch to commit to";
    };

    commitSchedule = lib.mkOption {
      type = lib.types.str;
      default = "daily";
      description = "When to auto-commit (systemd timer format)";
    };
  };

  config = lib.mkIf cfg.enable {
    systemd.timers.host-auto-commit = {
      description = "Auto-commit configuration changes";
      wantedBy = [ "timers.target" ];
      timerConfig = {
        OnCalendar = cfg.commitSchedule;
        Persistent = true;
      };
    };

    systemd.services.host-auto-commit = {
      description = "Commit and push host configuration changes";
      serviceConfig = {
        Type = "oneshot";
        User = config.hostSpec.primaryUsername;
        ExecStart = "${commitScript}";
        WorkingDirectory = cfg.repoPath;
      };
    };

    # Add manual command
    environment.systemPackages = [
      (pkgs.writeShellScriptBin "host-commit" ''
        exec ${commitScript} "$@"
      '')
    ];
  };
}
```

### 3. Conflict Resolution Strategy
**File**: Extend `modules/common/auto-upgrade.nix`

```nix
# Before git pull
old_commit=$(git rev-parse HEAD)

# Try to pull with rebase
if ! git pull --rebase origin dev; then
  echo "Merge conflict detected"

  case ${cfg.conflictStrategy} in
    prefer-remote)
      git reset --hard origin/dev
      ;;
    prefer-local)
      git rebase --abort
      git reset --hard "$old_commit"
      ;;
    abort)
      git rebase --abort
      exit 1
      ;;
  esac
fi
```

### 4. Role Configuration

**Servers** (`roles/form-server.nix`):
```nix
# Commit changes but don't auto-push (review first)
myModules.system.gitManagement = {
  enable = true;
  autoPush = false;
  commitSchedule = "weekly";
};

# Prefer remote changes on conflict
myModules.common.autoUpgrade = {
  conflictStrategy = "prefer-remote";
};
```

**Development Host** (e.g., `hosts/phenix/default.nix`):
```nix
# Can auto-push (workstation is source of truth)
myModules.system.gitManagement = {
  enable = true;
  autoPush = true;
  commitSchedule = "daily";
};

# Prefer local changes on conflict
myModules.common.autoUpgrade = {
  conflictStrategy = "prefer-local";
};
```

### 5. Testing Plan

**Phase A: Boot Failure Detection**
1. Deploy to griefling
2. Pin golden generation: `sudo pin-golden`
3. Make a change that breaks boot (e.g., disable sshd)
4. Rebuild and reboot
5. Verify system detects failure
6. Reboot again
7. Verify automatic rollback to golden

**Phase B: Commit Automation**
1. Enable git management on griefling
2. Make a local change (e.g., edit a file)
3. Run: `sudo host-commit`
4. Verify commit created with proper message
5. Check git log shows automated commit

**Phase C: End-to-End GitOps**
1. Host A: Make change, commit, push
2. Host B: Auto-upgrade pulls change
3. Host B: Builds, validates, switches
4. Host B: Boots successfully, confirms
5. Both hosts now running same config

**Phase D: Failure Recovery**
1. Host A: Make breaking change, commit, push
2. Host B: Auto-upgrade pulls change
3. Host B: Build fails â†’ validation fails â†’ rollback git
4. Host B stays on working config
5. Host A: Fix issue, commit, push
6. Host B: Successfully upgrades

## Success Criteria
- [ ] Boot failure detection works
- [ ] Automatic rollback to golden after 2 failed boots
- [ ] Host commit automation works
- [ ] Merge conflict handling works
- [ ] End-to-end GitOps flow successful
- [ ] Failure recovery works correctly

## Safety Notes
- Start with autoPush=false for all hosts initially
- Test thoroughly on griefling before production
- Ensure SSH access via other means (console) in case of lockout
- Document rollback procedures
- Consider notification system for failures

## Future Enhancements
- Notification system (ntfy, email)
- Web dashboard for system status
- Centralized logging of upgrade events
- Automatic issue creation for failures
