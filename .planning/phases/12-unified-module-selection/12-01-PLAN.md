---
phase: 12-unified-module-selection
plan: 01
type: execute
---

<objective>
Create the core selection system infrastructure - directory scanner and list-based options.

Purpose: Establish the foundation for unified module selection that both roles and hosts will use.
Output: `lib/modules.nix` with discovery helpers, `modules/selection.nix` with typed list options.
</objective>

<execution_context>
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/workflows/execute-phase.md
@~/.claude/plugins/marketplaces/taches-cc-resources/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@lib/default.nix
@modules/common/host-spec.nix
@roles/form-desktop.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create module discovery helper in lib</name>
  <files>lib/modules.nix, lib/default.nix</files>
  <action>
Create `lib/modules.nix` with helper functions:

1. `scanModuleDir` - Given a directory path, returns list of module names (filename without .nix, excluding default.nix)
2. `moduleNamesToEnum` - Converts list of names to `lib.types.enum` for LSP autocompletion

Example usage:
```nix
# Scans modules/services/desktop/ and returns [ "plasma" "hyprland" "niri" "wayland" "waybar" "common" ]
lib.custom.scanModuleDir ./modules/services/desktop
```

Wire into `lib/default.nix` so helpers are available as `lib.custom.*`.

AVOID: Don't make this overly complex. Simple file listing is sufficient - no need to parse nix files or check for enable options.
  </action>
  <verify>nix repl loads lib and `lib.custom.scanModuleDir` function exists</verify>
  <done>Helper functions defined and accessible via lib.custom</done>
</task>

<task type="auto">
  <name>Task 2: Create unified selection.nix with list-based options</name>
  <files>modules/selection.nix, modules/common/default.nix</files>
  <action>
Create `modules/selection.nix` that defines the `modules.*` option namespace:

```nix
options.modules = {
  desktop = lib.mkOption {
    type = lib.types.listOf (lib.types.enum [ /* discovered from modules/services/desktop */ ]);
    default = [];
    description = "Desktop environments and window managers to enable";
  };
  apps = lib.mkOption {
    type = lib.types.listOf (lib.types.enum [ /* discovered from modules/apps */ ]);
    default = [];
    description = "Applications to enable";
  };
  services = lib.mkOption {
    type = lib.types.listOf (lib.types.enum [ /* discovered from modules/services */ ]);
    default = [];
    description = "Services to enable";
  };
  development = lib.mkOption {
    type = lib.types.listOf (lib.types.enum [ /* discovered from modules/apps/development */ ]);
    default = [];
    description = "Development tools to enable";
  };
};
```

Use the lib helpers from Task 1 to dynamically populate enum values from actual module files.

Import selection.nix from `modules/common/default.nix`.

AVOID: Don't hardcode module lists - derive them from the filesystem for maintainability.
  </action>
  <verify>nix eval .#nixosConfigurations.griefling.options.modules shows the new options with enum types</verify>
  <done>modules.* options defined with enum types derived from filesystem</done>
</task>

<task type="auto">
  <name>Task 3: Build translation layer from selections to enable flags</name>
  <files>modules/selection.nix</files>
  <action>
Add config section to `modules/selection.nix` that translates list selections to enable flags:

```nix
config = {
  # Desktop selections -> myModules.desktop.*.enable
  myModules.desktop.plasma.enable = lib.mkIf (builtins.elem "plasma" config.modules.desktop) true;
  myModules.desktop.hyprland.enable = lib.mkIf (builtins.elem "hyprland" config.modules.desktop) true;
  # ... etc for all desktop modules

  # Apps selections -> myModules.apps.*.enable
  myModules.apps.media.enable = lib.mkIf (builtins.elem "media" config.modules.apps) true;
  # ... etc
};
```

Create a helper function `enableFromList` to reduce boilerplate:
```nix
enableFromList = category: moduleName:
  lib.mkIf (builtins.elem moduleName config.modules.${category}) true;
```

AVOID: Don't remove the existing myModules.*.enable pattern - this translation layer sits on top, providing a nicer interface while maintaining backwards compatibility.
  </action>
  <verify>Setting `modules.desktop = [ "plasma" ];` in a test config results in `myModules.desktop.plasma.enable = true`</verify>
  <done>Translation layer converts list selections to enable flags correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `nix flake check --no-build` passes
- [ ] `lib.custom.scanModuleDir` returns correct module names
- [ ] `modules.*` options have typed enums (LSP can autocomplete)
- [ ] Translation layer correctly enables modules based on list selections
</verification>

<success_criteria>
- All tasks completed
- Selection system works alongside existing myModules.*.enable pattern
- Enum types enable LSP autocompletion
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-unified-module-selection/12-01-SUMMARY.md`
</output>
