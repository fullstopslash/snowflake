---
phase: 07-vikunja-hardening
plan: 02
type: execute
---

<objective>
Add binary validation to hooks and migrate from jq to jaq for better performance.

Purpose: Hooks silently fail if binaries aren't found after `command -v`. The jq tool is slower than jaq for simple JSON operations. Additionally, jq string interpolation in filters can cause injection issues.
Output: Robust hooks with binary validation, jaq for all JSON operations, safe --arg interpolation.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@roles/vikunja-sync.nix
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add binary existence validation after command -v</name>
  <files>roles/vikunja-sync.nix</files>
  <action>
  In both on-add-vikunja and on-modify-vikunja hooks, add validation after `command -v`:

  Current (unsafe):
  ```sh
  VIKUNJA_DIRECT=$(command -v vikunja-direct)
  JAQ=$(command -v jaq)
  TASK=$(command -v task)
  ```

  Fixed (fail-open pattern):
  ```sh
  VIKUNJA_DIRECT=$(command -v vikunja-direct) || true
  JAQ=$(command -v jaq) || true
  TASK=$(command -v task) || true

  # If required binaries missing, output task unchanged and exit
  if [ -z "$VIKUNJA_DIRECT" ] || [ -z "$JAQ" ]; then
    echo "$task_json"  # on-add: output task_json; on-modify: output modified_json
    exit 0  # Fail open - don't block task operations
  fi
  ```

  This ensures:
  - Task operations never blocked by sync issues
  - Clear silent failure (task works, sync skipped)
  - No cryptic errors from empty variable expansion
  </action>
  <verify>Read generated hook scripts; verify validation block exists after command -v calls</verify>
  <done>Both hooks validate binary existence and fail-open gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Replace jq with jaq throughout</name>
  <files>roles/vikunja-sync.nix</files>
  <action>
  Replace all jq references with jaq:

  1. Change variable name: `JQ` → `JAQ`
  2. Change command lookup: `command -v jq` → `command -v jaq`
  3. Change all invocations: `"$JQ"` → `"$JAQ"`

  jaq is a Rust reimplementation of jq that is significantly faster for simple operations.
  The filter syntax is identical for basic operations used here (`.project`, `-r`, `-c`).

  Also add `pkgs.jaq` to any runtimeInputs or environment.systemPackages that currently have `pkgs.jq`.

  Files to update:
  - on-add-vikunja hook (2 occurrences)
  - on-modify-vikunja hook (3 occurrences)
  - Any other scripts in vikunja-sync.nix using jq
  </action>
  <verify>Grep generated scripts for "jq" - should find zero matches; grep for "jaq" - should find expected matches</verify>
  <done>All JSON processing uses jaq, no jq references remain</done>
</task>

<task type="auto">
  <name>Task 3: Use jaq --arg for safe value interpolation</name>
  <files>roles/vikunja-sync.nix</files>
  <action>
  The current code uses direct Nix interpolation in jaq filters which can break with special characters:

  Current (unsafe):
  ```sh
  task_json=$(echo "$task_json" | "$JAQ" -c '.project = "${cfg.defaultProject}"')
  ```

  Fixed (safe):
  ```sh
  task_json=$(echo "$task_json" | "$JAQ" -c --arg proj "${cfg.defaultProject}" '.project = $proj')
  ```

  Using `--arg` ensures:
  - Proper escaping of special characters (quotes, backslashes)
  - No shell injection via project names
  - Works with spaces, unicode, etc.

  Apply this pattern to ALL jaq invocations where Nix variables are interpolated into filters.
  In on-add-vikunja, this is the `.project = ...` filter.
  </action>
  <verify>Inspect generated hook scripts; verify --arg usage for interpolated values</verify>
  <done>All jaq filters use --arg for dynamic values, no direct interpolation in filter strings</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `nix eval` on the module succeeds
- [ ] Generated hooks contain binary validation with fail-open pattern
- [ ] No "jq" string appears in generated scripts (only "jaq")
- [ ] jaq invocations use `--arg` for Nix-interpolated values
- [ ] `which jaq` returns a path on the system
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Hooks fail gracefully when binaries missing
- All JSON processing uses jaq (faster)
- No injection risk from special characters in project names
</success_criteria>

<output>
After completion, create `.planning/phases/07-vikunja-hardening/07-02-SUMMARY.md`
</output>
