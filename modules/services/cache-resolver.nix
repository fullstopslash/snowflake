# Runtime cache resolver service
#
# Dynamically resolves waterbug.lan binary cache at boot time and generates
# appropriate nix.conf substituter configuration. Falls back gracefully to
# cache.nixos.org when waterbug is unreachable.
#
# Discovery methods (tried in order):
#   1. Override file (/etc/cache-resolver/waterbug-override) - for VM environments
#   2. DNS lookup (waterbug.lan)
#   3. mDNS/Avahi query (waterbug.local)
#   4. Broadcast ping to common subnets (10.0.0.0/8, 192.168.0.0/16)
#
# Outputs:
#   - /run/cache-resolver/waterbug-ip - Resolved IP address (if found)
#   - /run/cache-resolver/nix.conf - Generated nix substituter config
{
  config,
  pkgs,
  lib,
  ...
}:
let
  cfg = config.myModules.services.buildCache;

  # Resolver script that discovers waterbug.lan and generates nix.conf
  resolverScript = pkgs.writeShellScript "cache-resolver" ''
    set -euo pipefail

    # Runtime directory for resolver outputs
    RUNTIME_DIR="/run/cache-resolver"
    mkdir -p "$RUNTIME_DIR"

    WATERBUG_IP=""
    CACHE_PORT="9999"
    TIMEOUT=10

    log() {
      echo "[cache-resolver] $1" >&2
    }

    # Method 1: Check for override file (VM environments)
    if [ -f /etc/cache-resolver/waterbug-override ]; then
      WATERBUG_IP=$(cat /etc/cache-resolver/waterbug-override | tr -d '[:space:]')
      log "Using override IP: $WATERBUG_IP"
    fi

    # Method 2: DNS lookup (for networks with proper DNS)
    if [ -z "$WATERBUG_IP" ]; then
      log "Attempting DNS resolution for waterbug.lan..."
      if WATERBUG_IP=$(${pkgs.glibc.bin}/bin/getent hosts waterbug.lan 2>/dev/null | ${pkgs.gawk}/bin/awk '{print $1}' | head -1); then
        if [ -n "$WATERBUG_IP" ]; then
          log "DNS resolved waterbug.lan -> $WATERBUG_IP"
        fi
      fi
    fi

    # Method 3: mDNS/Avahi query (fallback to .local)
    if [ -z "$WATERBUG_IP" ]; then
      log "Attempting mDNS resolution for waterbug.local..."
      if ${pkgs.avahi}/bin/avahi-resolve -4 -n waterbug.local >/dev/null 2>&1; then
        WATERBUG_IP=$(${pkgs.avahi}/bin/avahi-resolve -4 -n waterbug.local 2>/dev/null | ${pkgs.gawk}/bin/awk '{print $2}' | head -1)
        if [ -n "$WATERBUG_IP" ]; then
          log "mDNS resolved waterbug.local -> $WATERBUG_IP"
        fi
      fi
    fi

    # Method 4: Broadcast ping to common subnets (last resort)
    # This is intentionally skipped for now to keep timeout fast
    # Can be enabled if needed, but adds significant delay
    # if [ -z "$WATERBUG_IP" ]; then
    #   log "Attempting broadcast discovery..."
    #   # Ping broadcast addresses and look for waterbug
    #   # This is complex and slow, skipping for now
    # fi

    # Test connectivity if we found an IP
    CACHE_AVAILABLE=false
    if [ -n "$WATERBUG_IP" ]; then
      log "Testing connectivity to $WATERBUG_IP:$CACHE_PORT..."
      if timeout "$TIMEOUT" ${pkgs.netcat}/bin/nc -z -w 5 "$WATERBUG_IP" "$CACHE_PORT" 2>/dev/null; then
        log "Cache server reachable at $WATERBUG_IP:$CACHE_PORT"
        CACHE_AVAILABLE=true
        echo "$WATERBUG_IP" > "$RUNTIME_DIR/waterbug-ip"
      else
        log "Cache server not reachable at $WATERBUG_IP:$CACHE_PORT"
        WATERBUG_IP=""
      fi
    fi

    # Generate nix.conf with appropriate substituters
    if [ "$CACHE_AVAILABLE" = true ]; then
      log "Generating nix.conf with waterbug cache ($WATERBUG_IP:$CACHE_PORT)"
      cat > "$RUNTIME_DIR/nix.conf" <<EOF
# Generated by cache-resolver.service
# waterbug cache available at $WATERBUG_IP:$CACHE_PORT
substituters = http://$WATERBUG_IP:$CACHE_PORT/system https://cache.nixos.org
EOF
    else
      log "Generating nix.conf without waterbug cache (fallback mode)"
      cat > "$RUNTIME_DIR/nix.conf" <<EOF
# Generated by cache-resolver.service
# waterbug cache not available, using upstream only
substituters = https://cache.nixos.org
EOF
    fi

    log "Cache resolver complete"
    exit 0
  '';

in
{
  options.myModules.services.buildCache.dynamicResolution = lib.mkOption {
    type = lib.types.bool;
    default = true;
    description = ''
      Enable dynamic runtime resolution of waterbug.lan cache server.
      When enabled, the cache-resolver service runs at boot to discover
      the cache server and configure nix substituters dynamically.

      When disabled, uses static serverUrl configuration (for advanced users).
    '';
  };

  config = lib.mkIf (cfg.enable && cfg.dynamicResolution) {
    # Runtime cache resolver service
    systemd.services.cache-resolver = {
      description = "Resolve waterbug.lan binary cache and configure substituters";
      wantedBy = [ "multi-user.target" ];
      before = [ "nix-daemon.service" ];
      wants = [ "network-online.target" ];
      after = [ "network-online.target" ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStart = "${resolverScript}";
        TimeoutStartSec = "10s"; # Fast fail if cache unavailable
        Restart = "on-failure";
        RestartSec = "5s";

        # Runtime directory permissions
        RuntimeDirectory = "cache-resolver";
        RuntimeDirectoryMode = "0755";

        # Security hardening
        PrivateTmp = true;
        ProtectSystem = "strict";
        ProtectHome = true;
        NoNewPrivileges = true;
      };
    };
  };
}
